<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 3 实例]]></title>
    <url>%2F2019%2F08%2F02%2Fcjz5ji22o001j1sdaw48xf12c%2F</url>
    <content type="text"><![CDATA[摄氏度转华氏度 123a = float(input("输入摄氏度："))b = a * 1.8 + 32print("摄氏度：&#123;&#125;℃ = 华氏度：&#123;&#125;℉".format(a, b)) 求园的面积 123r = float(input("输入园半径："))area = math.pi*r**2print("半径为&#123;&#125;的园面积为&#123;&#125;".format(r, area)) 开平方根 123num1 = float(input("输入一个数："))result = num1 ** 0.5print("&#123;&#125;开平方=&#123;&#125;".format(num1, result)) 求三角形面积 123456a = float(input("输入边长："))b = float(input("输入边长："))c = float(input("输入边长："))p = (a + b + c) / 2s = (p * (p - a) * (p - b) * (p - c)) ** 0.5print("边长为&#123;&#125;，&#123;&#125;，&#123;&#125; 的三角形面积为&#123;&#125;".format(a, b, c, s)) 判断输入字符串是否为数字 123456789101112131415def is_number(s): """判断输入字符串是否为数字""" try: float(s) return True except ValueError: pass try: import unicodedata for i in s: unicodedata.numeric(i) return True except (ValueError, TypeError): pass return False 判断是否是奇数 123456789101112def is_odd(n): """判断是否是奇数""" try: if float(n) % 2 == 1: print("奇数") return True else: print("偶数") except ValueError: print("参数错误") pass return False 判断是否为闰年 1234567891011def is_leap_year(year): """判断是否为闰年""" try: year = float(year) if year % 4 == 0 and year % 100 != 0 or year % 400 == 0: return True else: return False except ValueError: print("参数错误") pass 获取最大值 123def max_num(s): """获取最大值""" return max(s) 判断是否为质数 1234567891011def is_prime(num): """判断是否为质数""" try: num = int(num) for i in range(2, num): if num % i == 0: return False else: return True except ValueError: pass 输出指定范围内的质数 123456789101112131415def scope_prime(min, max): """输出指定范围内的质数""" try: min = int(min) max = int(max) prime = set() for i in range(min, max + 1): for j in range(2, i): if i % j == 0: break else: prime.add(i) return prime except (TypeError, ValueError): pass 阶乘 12345678910111213141516def factorial(num): """阶乘""" try: num = int(num) if num == 1: return 1 else: # 递归实现 return num * factorial(num - 1) # 非递归实现 # factorial = 1 # for i in range(1, num + 1): # factorial *= i # return factorial except(TypeError, ValueError): pass 乘法表 123456def get_multiplication(): """乘法表""" for i in range(1, 10): for j in range(1, i + 1): print("&#123;&#125;x&#123;&#125;=&#123;&#125;\t".format(i, j, i * j), end="") print() 斐波那契数列 12345678def get_fibonacci(n): """斐波那契数列(0,1,1,2,3,5..)""" fib_list = [0, 1] if n == 1: return [0, ] for i in range(2, n): fib_list.append(fib_list[i - 2] + fib_list[i - 1]) return fib_list 阿姆斯特朗数 123456789101112131415161718def get_armstrong(n): """阿姆斯特朗数""" a = [] b = [] for i in range(1, n + 1): temp = i count = 0 sum_num = 0 a.clear() while int(temp % 10) != 0 or int(temp / 10) != 0: a.append(int(temp % 10)) temp /= 10 count += 1 for j in iter(a): sum_num += j ** count if sum_num == i: b.append(i) return b 进制转 1234567891011def change_type(num): # 十进制转二进制 print("二进制为：&#123;&#125;".format(bin(num))) # 十进制转八进制 print("八进制为：&#123;&#125;".format(oct(num))) # 十进制转十六进制 print("十六进制为：&#123;&#125;".format(hex(num))) # 字符转ASCII码 print("ASCII码为：&#123;&#125;".format(ord(num))) # ASCII码转字符 print("字符为：&#123;&#125;".format(chr(num))) 最大公约数 12345678def get_max_divisor(x, y): """最大公约数""" if x &gt; y: x, y = y, x for i in range(1, x + 1): if x % i == 0 and y % i == 0: divisor = i return divisor 最小公倍数 12345678def get_min_multiple(x, y): """最小公倍数""" if x &lt; y: x, y = y, x multiple = y while multiple % x != 0 or multiple % y != 0: multiple += 1 return multiple 日历 123def my_calendar(year, month): """日历""" print(calendar.month(year, month)) 递归 斐波那契数列 123456def recur_fibo(n): """递归 斐波那契数列""" if n &lt;= 1: return n else: return recur_fibo(n - 1) + recur_fibo(n - 2) 文件输入输出 1234567def file_test(file_name, my_input): """文件输入输出""" with open(file_name, 'w+') as file: file.write(my_input) with open(file_name, 'r') as file: output = file.read() return output 字符串大小写转换 1234567def up2down_or_down2up(my_str): """字符串大小写转换""" my_str = str(my_str) print(my_str.upper()) print(my_str.lower()) print(my_str.title()) print(my_str.capitalize()) 获得昨天日期 123456def get_yesterday(): """获得昨天日期""" today = datetime.date.today() one_day = datetime.timedelta(days=1) yesterday = today - one_day return yesterday 约瑟夫环 1234567891011121314151617181920212223242526def joseph(): """约瑟夫环""" people = [] for i in range(0, 30): # 1,在船上，0,落水 people.append(1) # 报数 check = 0 # 落水人数 num = 0 # 指针 index = -1 while num &lt; 15: # 报数 check = check + 1 index = index + 1 index = index % 30 while people[index] == 0: index = index + 1 index = index % 30 if check == 9: people[index] = 0 print('&#123;&#125;号下船'.format(index + 1)) num = num + 1 check = 0 # print(str(people)) 约瑟夫环 123456789def joseph2(): """约瑟夫环""" people = list(range(30)) while len(people) &gt; 15: i = 1 while i &lt; 9: people.append(people.pop(0)) i += 1 print('&#123;:2d&#125;号下船了'.format(people.pop(0))) 秒表功能实现 12345678910111213141516def stopwatch(): """秒表功能实现""" print('按下回车开始计时，按下Ctrl+c停止计时') while True: try: input() starttime = time.time() print('开始') while True: print('计时：', round(time.time() - starttime, 0), '秒', end='\r') time.sleep(1) except KeyboardInterrupt: print('结束') endtime = time.time() print('总共的时间为：', round(endtime - starttime, 2), 'secs') break 计算n个自然数的立方和 123def cube_sum(n): """计算n个自然数的立方和""" return sum([num ** 3 for num in range(1, n + 1)]) 数组翻转指定个数元素 123456def list_flip(arr, n): """数组翻转指定个数元素""" arr = list(arr) for i in range(n): arr.append(arr.pop(0)) return arr 数组首尾对调 1234def list_exchange(arr): """数组首尾对调""" arr[0], arr[len(arr) - 1] = arr[len(arr) - 1], arr[0] return arr 指定位置对调 12345678910def list_exchange(arr, x, y): # 数组指定位置对调 arr[x], arr[y] = arr[y], arr[x] # 判断数组中是否有3 if 3 in arr: print("数组中包含3") # 计算数组中元素出现的次数 print('数组中元素2出现了：&#123;&#125;次'.format(arr.count(2))) # 翻转数组 return [ele for ele in reversed(arr)] 正则表达式获取字符串中的url 12345def get_url(str): """正则表达式获取字符串中的url""" exp = r'https?://(?:[-\w.]|(?:%[\da-fA-F]&#123;2&#125;))+' url = re.findall(exp, str) return url 按key/value排序 1234567891011121314def sort_dic(): """按key/value排序""" key_value = &#123;2: 56, 1: 2, 5: 12, 4: 24, 6: 18, 3: 323&#125; key_value2 = &#123;7: 23, 8: 54&#125; print("按key排序") print(sorted(key_value.items())) # for i in sorted(key_value): # print((i, key_value[i]), end=' ') print("\n按value排序") print(sorted(key_value.items(), key=lambda kv: (kv[1], kv[0]))) print("字典值之和为：&#123;&#125;".format(sum(key_value.values()))) # 将字典2加入字典1 key_value.update(key_value2) print("两字典合并,key_value:&#123;&#125;, key_value2:&#123;&#125;".format(key_value, key_value2)) 时间转换 1234567891011a1 = "2019-7-20 23:40:00"# 先转换为时间数组timeArray = time.strptime(a1, "%Y-%m-%d %H:%M:%S")# 转换为时间戳timeStamp = int(time.mktime(timeArray))print(timeStamp)# 格式转换 - 转为 /otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)print(otherStyleTime)print("now:&#123;&#125;".format(datetime.datetime.now())) 二分查找 123456789101112131415161718192021def binary_search(arr, x): """二分查找,在有序数组arr中查找x所在的索引，找不到时返回-1""" left, right = 0, len(arr) - 1 while True: if right - left == 1: if arr[right] == x: return right elif arr[left] == x: return left else: return -1 else: mid = int((right + left) / 2) if x == arr[mid]: return mid elif x &gt; arr[mid]: left = mid continue elif x &lt; arr[mid]: right = mid continue 线性查找 123456def linear_search(arr, c): """线性查找""" for i in range(len(arr)): if arr[i] == c: return i return -1]]></content>
      <categories>
        <category>Python 3</category>
      </categories>
      <tags>
        <tag>实例</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F07%2F30%2Fcjz5ji1vc000d1sdagpn41yg2%2F</url>
    <content type="text"><![CDATA[​ 在笔试中经常会遇到很多需要手写代码的题，如果能完整的写出来最好，但如果不习惯手写或时间不够，可已选择写伪码，主要描述清楚关键的实现步骤。 笔试 写出Collection接口的实现 Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap 运行时获取class的磁盘路径 1&lt;YOUR CLASS&gt;.class.getProtectionDomain().getCodeSource().getSource().getLocation() Java多态的表现形式，代码如何实现 重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现；不同的对象调用同一个方法的到不同的结果。 继承父类 重写父类方法 向上转型 在工作中遇到或使用过的设计模式，手写实现一个设计模式（除了单例模式） Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），Observer（观察者模式）， State（状态模式）， Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。具体实现代码 手写代码，实现多线程对一整型对象递增，且数值不重复 123456789101112131415161718192021222324public class Test &#123; private static int num = 1; public static void main(String[] args) &#123; Test test = new Test(); Increasing inc = test.new Increasing(); for (int i=0;i&lt;=10;i++)&#123; Thread thread=new Thread(inc); thread.start(); &#125; &#125; private synchronized void add()&#123; num+=1; System.out.println(num); &#125; class Increasing implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;20;i++)&#123; add(); &#125; &#125; &#125;&#125; 快速获得数组int[] a = {1,2, 3, 5, 6, 12, 4, 7, 14, 9, 8}中第二大的数，写出关键代码 下面代码的时间复杂度为O(n)，不一定是最快的，但只需遍历一次 12345678910111213public static int getSecondMax(int[] a) &#123; int max = a[0]; int second = a[a.length - 1]; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; second = max; max = a[i]; &#125; else if (a[i] &gt; second &amp;&amp; a[i] &lt; max) &#123; second = a[i]; &#125; &#125; return second;&#125; 进程和线程的区别和联系？ 进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程线程 - 操作系统分配CPU的基本单位 面试 在之前项目中遇到什么问题，怎么解决。 mysql分页语句。 线程同步有哪几种方式。 eclipse的中查找类被调用的快捷键是什么。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3与Java的对比之面向对象]]></title>
    <url>%2F2019%2F07%2F28%2Fcjz5ji22l001i1sdaehbq04ti%2F</url>
    <content type="text"><![CDATA[类(class)是构造对象的模板或蓝图。由类构造(construct)对象的过程称为创建类的实例(instance)。 ——Java核心技术 类提供了一种组合数据和功能的方法。创建一个新类意味着创建一个新类型的对象，从而允许创建一个该类型的新实例。 ——Python3.7.4文档 在对于类的定义上，Python3与Java定义一致。 类​ 下面分别用Java和Python3编写一个People类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * People */public class People &#123; //实例域（成员变量） private String name; private int age; private String gender; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; //无参构造器 public People() &#123; System.out.println("【JPeople】无参构造器"); &#125; //带参构造器 public People(String name, int age, String gender) &#123; System.out.println("【JPeople】带参构造器"); this.name = name; this.age = age; this.gender = gender; &#125; //静态方法 public static void f() &#123; System.out.println("【JPeople】静态方法"); &#125; //实例方法 public void sayHello() &#123; System.out.println("【JPeople】"+this.name + " say：\"Hello\""); pf(); &#125; //私有方法 private void pf()&#123; System.out.println("【JPeople】私有方法"); &#125;&#125;public class PeopleTest &#123; public static void main(String[] args) &#123; People tom = new People("tom", 18, "male"); tom.sayHello(); People.f(); &#125;&#125; ​ Java执行结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class People: """People""" # 私有属性 __gift = 100 # 类属性 name = '' age = 0 # 限定对象只能绑定_gender属性 # __slots__=('_gender') # 实例化方法 def __init__(self, name, age, gender): print("【PPeople】构造方法") self.name = name self.age = age self._gender = gender # getter方法 @property def gender(self): return self._gender # setter方法 @gender.setter def gender(self,gender): self._gender=gender # 静态方法 @staticmethod def sf(): print("【PPeople】静态方法") # 类方法 @classmethod def cf(cls): print("【PPeople】类方法") # 实例方法 def say_hello(self): print("【PPeople】&#123;&#125; say：\"Hello!\",gift=&#123;&#125;".format(self.name, self.__gift)) self.__pf() # 私有方法 def __pf(self): print("【PPeople】私有方法")People.age += 1print(People.age)People.sf()tom = People('Tom', 18, 'male')tom.gender="female"print(tom.gender)tom.say_hello() ​ Python执行结果 小结 Java Python 私有属性 （成员变量）使用private关键字修饰 属性名双下划线开头__；不建议将属性设置为私有，建议以_(单下划线)开头，暗示属性为受保护的，不建议外部直接访问，建议使用getter、setter进行操作 类属性 无 类和对象都可以访问 构造方法 有参、无参构造器；方法名与类名相同 (实例化方法)方法名固定__init__ 实例方法 对象访问 (普通方法)对象访问，默认有参self 私有方法 使用private关键字修饰 方法名双下划线开头__ 静态方法 使用static关键字修饰 使用@staticmethod装饰器,可以无参 类方法 无 使用@classmethod装饰器,类和对象访问,默认参数cls 继承​ 在Java中是单继承继承，而Python可以多继承；下面分别使用Java和Python 3实现Student子类 12345678910111213141516171819202122232425262728293031323334public class Student extends People&#123; //学号 private String studentNumber; public String getStudentNumber() &#123; return studentNumber; &#125; public void setStudentNumber(String studentNumber) &#123; this.studentNumber = studentNumber; &#125; //子类无参构造器 public Student() &#123; &#125; //带参构造器 public Student(String name, int age, String gender, String studentNumber) &#123; //调用父类带参构造器 super(name, age, gender); System.out.println("【JStudent】带参构造器"); this.studentNumber = studentNumber; &#125; //重写父类方法 public void sayHello()&#123; System.out.println("【JStudent】"+this.getName() + " say：\"Hello\""); &#125; public static void main(String[] args) &#123; Student student_1 = new Student("Jerry", 17, "male", "0021"); student_1.sayHello(); &#125;&#125; ​ Java执行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243# 单继承class Student(People): # 子类构造方法 def __init__(self, name, age, gender, student_number): print("【PStudent】构造方法--开始") # 调用超类构造方法 super(Student, self).__init__(name, age, gender) self.student_number = student_number print("【PStudent】构造方法--结束") # 重写父类方法 def say_hello(self): print("【PStudent】&#123;&#125; say：\"Hello!\"".format(self.name)) # Child类,为多继承做准备class Child: def __init__(self, name, mom, dad): print("【PChild】构造方法") self.name = name self.mom = mom self.dad = dad def cry(self): print('【PChild】'+self.name + ":\'wow wow\'")# 多重继承class Kid(Student, Child): def __init__(self, name, age, gender, student_number, mom, dad): print("【PKid】构造方法--开始") Student.__init__(self, name, age, gender, student_number) Child.__init__(self, name, mom, dad) print("【PKid】构造方法--结束") def info(self): print('【PKid】'+', '.join(['%s:%s' % item for item in self.__dict__.items()]))# 创建一个Student对象jerry = Student("Jerry", 17, 'male', '0021')print(jerry.name)jerry.say_hello()# 创建一个Kid对象kid = Kid("小明", 12, "男", "0023", "Tom", "Jerry")kid.info() ​ Python执行结果 小结​ Java与Python 3 在掉用构造方法时顺序是一致的，但是Java在构造方法内调用父类构造方法语句super()必须放在方法体的第一句；而Python 3，对象是由 __new__()和__init__()协作构造完成，实例通过__new__方法被创建，使用__init__方法进行初始化；所以在调用父类方法之前，可以对参数进行定制修改。Python 3 的多继承，在搜索从父类继承的方法/属性时，可以简单认为是深度优先、从左至右；但为了保持单次调用，实际在调用时是动态的； 多态​ 实现多态的步骤：1.继承父类 2.重写父类方法 3.向上转型 1234567891011121314/**1.Teacher继承自People**/public class Teacher extends People &#123; public Teacher() &#123; &#125; public Teacher(String name, int age, String gender) &#123; super(name, age, gender); &#125; //2.重写sayHello方法 public void sayHello() &#123; System.out.println("【JTeacher】"+this.getName() + "：\" 同学们早上好！\""); &#125;&#125; 123456789public class Test &#123; public static void main(String[] args) &#123; //3.向上转型 People teacher= new Teacher("王阳明",45,"男"); teacher.sayHello(); People student =new Student("小明", 17, "男", "0021"); student.sayHello(); &#125;&#125; java运行结果： 1234567891011121314class Teacher(People): """继承自People""" def __init__(self, name, age, gender): print("【PTeacher】构造方法--开始") super(Teacher, self).__init__(name, age, gender) print("【PTeacher】构造方法--结束") def say_hello(self): print("【PTeacher】&#123;&#125; say：\"同学们好！\"".format(self.name)) people_1 = Student("小明", 12, "男", "0023")people_1.say_hello()people_2 = Teacher("王阳明", 45, "男")people_2.say_hello() Python运行结果： 小结 Python从语法层面并没有像Java那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod（class CLASSNAME(metaclass=ABCMeta):）包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python3</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7查杀nanoWath挖矿木马]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5ji1v500071sdaigqfegui%2F</url>
    <content type="text"><![CDATA[前几天在查看服务器时状态时发现cpu占用率达到了103% 这个VPS主要是拿来玩玩，平时上面并没有什么大的服务再运行，不可能会占满CPU的；用shell客户端连上VPS，执行ps aux，其中一个叫nanoWatch的进程cpu占用率达到了99.5% 直接杀掉这个进程kill -9 17305,再检查进程，没发现异常 过了没几分钟，cpu占用又满了，查看进程，这个进程又出现了； 找到/tmp/nanoWatch这个文件，删掉这个文件，再杀掉进程，过了几分钟，进进程再次出现。 我怀疑是定时启动的任务， crontab -l查看cron计划任务，显示出来了两个定时任务，每5分钟和7分钟执行一次下载文件，我手动把这个文件下下来，是一个脚本 删除定时任务crontab -r，删掉文件，杀掉进程，结束了。 过了两天，又出现CPU占用异常。 我之前一直是用root用户并使用20端口进行ssh连接，这是非常不安全的行为，很容易被端口扫描暴力破解密码登录服务器。简单的解决办法如下 [TOC] 修改ssh连接端口用 root 用户进入 /etc/ssh/ 1234cd /etc/ssh/#用 vi 打开 sshd_config 文件vim sshd_config#添加端口20022（22号是默认端口，注释掉也是默认开启的），并解开22端口注释 123456789#重启ssh systemctl restart sshd#查看防火墙规则firewall-cmd --permanent --list-port#向防火墙中添加端口firewall-cmd --zone=public --add-port=20022/tcp --permanentreaload #重新加载防火墙规则firewall-cmd --reload 12#查看20022端口是否添加成功firewall-cmd --zone=public --query-port=20022/tcp 断开ssh连接，换用20022端口连接修改/etc/ssh/sshd_config将22号端口注释掉 1234#重启sshsystemctl restart sshd#查看ssh监听的端口ss -tnlp|grep ssh 禁用root登入，使用普通用户登入12345#先创建一个普通用户test,同时给test用户设置密码adduser testpasswd test#接着禁用root登录(修改sshd_config文件)vi /etc/ssh/sshd_config 12#重启sshSystemctl restart sshd.service]]></content>
      <categories>
        <category>服务器安全</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker启动Redis]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5ji1v900091sda91qdmhzd%2F</url>
    <content type="text"><![CDATA[12#docker中启动redis并设置密码docker run -d --name myredis -p 6379:6379 redis --requirepass "mypassword"]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装RabbitMq]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5ji1vg000g1sdahqfzvc6e%2F</url>
    <content type="text"><![CDATA[12#设置rabbit默认用户与密码docker run -d --hostname rabbit-host --name rabbitMq -e RABBITMQ_DEFAULT_USER=username -e RABBITMQ_DEFAULT_PASS=password -p 5672:5672 -p 15672:15672 rabbitmq:3.7.3-management 12#在docker中停止rabbitMqdocker stop rabbitMq]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>RabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装Mysql5.7]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5ji1vk000k1sdanzuuu9ap%2F</url>
    <content type="text"><![CDATA[在Docker中mysql5.7安装和设置与8.0基本一致 1234567891011121314151617# docker 中下载 mysqldocker pull mysql:5.7#启动并设置root密码docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=your_password -d mysql:5.7#进入容器docker exec -it mysql bash#登录mysqlmysql -u root -p#设置root用户密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_password';#添加远程登录用户CREATE USER 'your_username'@'%' IDENTIFIED WITH mysql_native_password BY 'your_password';GRANT ALL PRIVILEGES ON *.* TO 'your_password'@'%';]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IDEA中使用Dockerfile]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5ji1ve000f1sdasn2a8yk6%2F</url>
    <content type="text"><![CDATA[在IDEA中使用Dockerfile简单步骤 在项目根目录创建Dockerfile文件 在Dockerfile中写入 1234567891011#引用基础镜像FROM java:8-jre#将需要在Docker中运行的jar包复制到镜像中ADD target/*.jar applicationName.jar#暴露端口EXPOSE 8888#容器启动时执行的命令ENTRYPOINT ["java", "-jar", "applicationName.jar", "--server.port=8888"] 使用maven打包项目，运行Dockerfile文件 ps:启动前需要配置IDEA与Docker服务器的连接]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Dockerflie</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud配置SSH连接统一配置中心]]></title>
    <url>%2F2019%2F07%2F19%2Fcjz5ji1uh00001sdalzvi4kyz%2F</url>
    <content type="text"><![CDATA[当时在配置ssh连接的时候不知不觉就掉坑里去了，对一些知识点没完全理解； 先说说的掉坑，复制id_rsa文件内的文本出来，放进bootstrap.yml的privateKey中，如下图 启动报错 12Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under &apos;spring.cloud.config.server.git&apos; to org.springframework.cloud.config.server.environment.MultipleJGitEnvironmentProperties failed: Reason: Property &apos;spring.cloud.config.server.git.privateKey&apos; is not a valid private key 我们看看官网怎么配spring.cloud.config.server.git的 有没有发现不一样，没错，官网配置的privateKey里少了前3行属性为什么？？？因为官网的秘钥在生成时是没有设置秘钥密码的，而我们的秘钥是有密码的，它没办法解密秘钥；解决办法两种： ==我们在生成秘钥时也不设置秘钥密码== ==在yml中配置的git属性添加passphrase== 下面是全配置过程，主要分3步 生成公钥与私钥打开Git Bash/Terminal，输入ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 引号里面替换成你的邮箱地址或标志自己身份的信息 提示保存秘钥的文件位置，直接回车保持默认位置 设置秘钥密码（直接回车则不设置秘钥密码），生成公钥、秘钥 完成之后可以在/root/.ssh/目录下找到公钥（id_rsa.pub）秘钥（id_rsa） 将公钥添加到git上复制id_rsa.pub的内容出来 打开github，进入需要拉取文件的仓库，进入设置标签页 点击Add Deploy key 输入GitHub密码确认 刚添加的公钥是灰色的，还没有被使用 在bootstrap.yml中配置把id_rsa的全部内容复制出来，放到private-key属性 注意： uri要用ssh形式的地址 ignore-local-ssh-settings设置为true，忽略本地的ssh配置 passphrase内要配置上面设置的秘钥密码 启动项目后，可以在Github的仓库设置中看到公钥已经被使用，变成了绿色。 至此spring-cloud-config使用ssh连接git就配置完成。 修改秘钥密码打开Git Bash/Terminal，输入ls-al ~/.ssh 检查之前是否已经生成了SSH key 如果是这样的那就说明已经生成过秘钥，可以选择修改修改私钥密码（passphrase）输入 ssh-keygen -p 直接回车继续，输入旧密码，然后输入两次新密码]]></content>
      <categories>
        <category>Java</category>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
