<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3与Java的对比之面向对象]]></title>
    <url>%2F2019%2F07%2F28%2Fcjyn7udw90000cgdal65dc037%2F</url>
    <content type="text"><![CDATA[类(class)是构造对象的模板或蓝图。由类构造(construct)对象的过程称为创建类的实例(instance)。 ——Java核心技术 类提供了一种组合数据和功能的方法。创建一个新类意味着创建一个新类型的对象，从而允许创建一个该类型的新实例。 ——Python3.7.4文档 在对于类的定义上，Python3与Java定义一致。 类​ 下面分别用Java和Python3编写一个People类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * People */public class People &#123; //实例域（成员变量） private String name; private int age; private String gender; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; //无参构造器 public People() &#123; System.out.println("【JPeople】无参构造器"); &#125; //带参构造器 public People(String name, int age, String gender) &#123; System.out.println("【JPeople】带参构造器"); this.name = name; this.age = age; this.gender = gender; &#125; //静态方法 public static void f() &#123; System.out.println("【JPeople】静态方法"); &#125; //实例方法 public void sayHello() &#123; System.out.println("【JPeople】"+this.name + " say：\"Hello\""); pf(); &#125; //私有方法 private void pf()&#123; System.out.println("【JPeople】私有方法"); &#125;&#125;public class PeopleTest &#123; public static void main(String[] args) &#123; People tom = new People("tom", 18, "male"); tom.sayHello(); People.f(); &#125;&#125; ​ Java执行结果 12345678910111213141516171819202122232425262728293031323334353637383940class People: """People""" # 私有属性 __gift = 100 # 类属性 name = '' age = 0 # 实例化方法 def __init__(self, name, age, gender): print("【PPeople】构造方法") self.name = name self.age = age self.gender = gender # 静态方法 @staticmethod def sf(): print("【PPeople】静态方法") # 类方法 @classmethod def cf(cls): print("【PPeople】类方法") # 实例方法 def say_hello(self): print("【PPeople】&#123;&#125; say：\"Hello!\",gift=&#123;&#125;".format(self.name, self.__gift)) self.__pf() # 私有方法 def __pf(self): print("【PPeople】私有方法")People.age += 1print(People.age)People.sf()tom = People('Tom', 18, 'male')print(tom.gender)tom.say_hello() ​ Python执行结果 小结 Java Python 私有属性 （成员变量）使用private关键字修饰 属性名双下划线开头__ 类属性 无 类和对象都可以访问 构造方法 有参、无参构造器；方法名与类名相同 (实例化方法)方法名固定__init__ 实例方法 对象访问 (普通方法)对象访问，默认有参self 私有方法 使用private关键字修饰 方法名双下划线开头__ 静态方法 使用static关键字修饰 使用@staticmethod装饰器,可以无参 类方法 无 使用@classmethod装饰器,类和对象访问,默认参数cls 继承​ 在Java中是单继承继承，而Python可以多继承；下面分别使用Java和Python 3实现Student子类 12345678910111213141516171819202122232425262728293031323334public class Student extends People&#123; //学号 private String studentNumber; public String getStudentNumber() &#123; return studentNumber; &#125; public void setStudentNumber(String studentNumber) &#123; this.studentNumber = studentNumber; &#125; //子类无参构造器 public Student() &#123; &#125; //带参构造器 public Student(String name, int age, String gender, String studentNumber) &#123; //调用父类带参构造器 super(name, age, gender); System.out.println("【JStudent】带参构造器"); this.studentNumber = studentNumber; &#125; //重写父类方法 public void sayHello()&#123; System.out.println("【JStudent】"+this.getName() + " say：\"Hello\""); &#125; public static void main(String[] args) &#123; Student student_1 = new Student("Jerry", 17, "male", "0021"); student_1.sayHello(); &#125;&#125; ​ Java执行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243# 单继承class Student(People): # 子类构造方法 def __init__(self, name, age, gender, student_number): print("【PStudent】构造方法--开始") # 调用超类构造方法 super(Student, self).__init__(name, age, gender) self.student_number = student_number print("【PStudent】构造方法--结束") # 重写父类方法 def say_hello(self): print("【PStudent】&#123;&#125; say：\"Hello!\"".format(self.name)) # Child类,为多继承做准备class Child: def __init__(self, name, mom, dad): print("【PChild】构造方法") self.name = name self.mom = mom self.dad = dad def cry(self): print('【PChild】'+self.name + ":\'wow wow\'")# 多重继承class Kid(Student, Child): def __init__(self, name, age, gender, student_number, mom, dad): print("【PKid】构造方法--开始") Student.__init__(self, name, age, gender, student_number) Child.__init__(self, name, mom, dad) print("【PKid】构造方法--结束") def info(self): print('【PKid】'+', '.join(['%s:%s' % item for item in self.__dict__.items()]))# 创建一个Student对象jerry = Student("Jerry", 17, 'male', '0021')print(jerry.name)jerry.say_hello()# 创建一个Kid对象kid = Kid("小明", 12, "男", "0023", "Tom", "Jerry")kid.info() ​ Python执行结果 小结​ Java与Python 3 在掉用构造方法时顺序是一致的，但是Java在构造方法内调用父类构造方法语句super()必须放在方法体的第一句；而Python 3，对象是由 __new__()和__init__()协作构造完成，实例通过__new__方法被创建，使用__init__方法进行初始化；所以在调用父类方法之前，可以对参数进行定制修改。Python 3 的多继承，在搜索从父类继承的方法/属性时，可以简单认为是深度优先、从左至右；但为了保持单次调用，实际在调用时是动态的；]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>Java</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7查杀nanoWath挖矿木马]]></title>
    <url>%2F2019%2F07%2F21%2Fcjyn7udxa000fcgdarmue0r5c%2F</url>
    <content type="text"><![CDATA[前几天在查看服务器时状态时发现cpu占用率达到了103% 这个VPS主要是拿来玩玩，平时上面并没有什么大的服务再运行，不可能会占满CPU的；用shell客户端连上VPS，执行ps aux，其中一个叫nanoWatch的进程cpu占用率达到了99.5% 直接杀掉这个进程kill -9 17305,再检查进程，没发现异常 过了没几分钟，cpu占用又满了，查看进程，这个进程又出现了； 找到/tmp/nanoWatch这个文件，删掉这个文件，再杀掉进程，过了几分钟，进进程再次出现。 我怀疑是定时启动的任务， crontab -l查看cron计划任务，显示出来了两个定时任务，每5分钟和7分钟执行一次下载文件，我手动把这个文件下下来，是一个脚本 删除定时任务crontab -r，删掉文件，杀掉进程，结束了。 过了两天，又出现CPU占用异常。 我之前一直是用root用户并使用20端口进行ssh连接，这是非常不安全的行为，很容易被端口扫描暴力破解密码登录服务器。简单的解决办法如下 [TOC] 修改ssh连接端口用 root 用户进入 /etc/ssh/ 1234cd /etc/ssh/#用 vi 打开 sshd_config 文件vim sshd_config#添加端口20022（22号是默认端口，注释掉也是默认开启的），并解开22端口注释 123456789#重启ssh systemctl restart sshd#查看防火墙规则firewall-cmd --permanent --list-port#向防火墙中添加端口firewall-cmd --zone=public --add-port=20022/tcp --permanentreaload #重新加载防火墙规则firewall-cmd --reload 12#查看20022端口是否添加成功firewall-cmd --zone=public --query-port=20022/tcp 断开ssh连接，换用20022端口连接修改/etc/ssh/sshd_config将22号端口注释掉 1234#重启sshsystemctl restart sshd#查看ssh监听的端口ss -tnlp|grep ssh 禁用root登入，使用普通用户登入12345#先创建一个普通用户test,同时给test用户设置密码adduser testpasswd test#接着禁用root登录(修改sshd_config文件)vi /etc/ssh/sshd_config 12#重启sshSystemctl restart sshd.service]]></content>
      <categories>
        <category>服务器安全</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker启动Redis]]></title>
    <url>%2F2019%2F07%2F21%2Fcjyn7udx4000bcgdaez5bzz4b%2F</url>
    <content type="text"><![CDATA[12#docker中启动redis并设置密码docker run -d --name myredis -p 6379:6379 redis --requirepass "mypassword"]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装RabbitMq]]></title>
    <url>%2F2019%2F07%2F21%2Fcjyn7udxe000icgdayqxxusm0%2F</url>
    <content type="text"><![CDATA[12#设置rabbit默认用户与密码docker run -d --hostname rabbit-host --name rabbitMq -e RABBITMQ_DEFAULT_USER=username -e RABBITMQ_DEFAULT_PASS=password -p 5672:5672 -p 15672:15672 rabbitmq:3.7.3-management 12#在docker中停止rabbitMqdocker stop rabbitMq]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>RabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装Mysql5.7]]></title>
    <url>%2F2019%2F07%2F21%2Fcjyn7udxc000hcgdaxq4hoc7v%2F</url>
    <content type="text"><![CDATA[在Docker中mysql5.7安装和设置与8.0基本一致 1234567891011121314151617# docker 中下载 mysqldocker pull mysql:5.7#启动并设置root密码docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=your_password -d mysql:5.7#进入容器docker exec -it mysql bash#登录mysqlmysql -u root -p#设置root用户密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_password';#添加远程登录用户CREATE USER 'your_username'@'%' IDENTIFIED WITH mysql_native_password BY 'your_password';GRANT ALL PRIVILEGES ON *.* TO 'your_password'@'%';]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IDEA中使用Dockerfile]]></title>
    <url>%2F2019%2F07%2F21%2Fcjyn7udy50018cgdar7uddfx8%2F</url>
    <content type="text"><![CDATA[在IDEA中使用Dockerfile简单步骤 在项目根目录创建Dockerfile文件 在Dockerfile中写入 1234567891011#引用基础镜像FROM java:8-jre#将需要在Docker中运行的jar包复制到镜像中ADD target/*.jar applicationName.jar#暴露端口EXPOSE 8888#容器启动时执行的命令ENTRYPOINT ["java", "-jar", "applicationName.jar", "--server.port=8888"] 使用maven打包项目，运行Dockerfile文件 ps:启动前需要配置IDEA与Docker服务器的连接]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Dockerflie</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud配置SSH连接统一配置中心]]></title>
    <url>%2F2019%2F07%2F19%2Fcjyn7udwy0009cgdal1eqlvnd%2F</url>
    <content type="text"><![CDATA[当时在配置ssh连接的时候不知不觉就掉坑里去了，对一些知识点没完全理解； 先说说的掉坑，复制id_rsa文件内的文本出来，放进bootstrap.yml的privateKey中，如下图 启动报错 12Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under &apos;spring.cloud.config.server.git&apos; to org.springframework.cloud.config.server.environment.MultipleJGitEnvironmentProperties failed: Reason: Property &apos;spring.cloud.config.server.git.privateKey&apos; is not a valid private key 我们看看官网怎么配spring.cloud.config.server.git的 有没有发现不一样，没错，官网配置的privateKey里少了前3行属性为什么？？？因为官网的秘钥在生成时是没有设置秘钥密码的，而我们的秘钥是有密码的，它没办法解密秘钥；解决办法两种： ==我们在生成秘钥时也不设置秘钥密码== ==在yml中配置的git属性添加passphrase== 下面是全配置过程，主要分3步 生成公钥与私钥打开Git Bash/Terminal，输入ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 引号里面替换成你的邮箱地址或标志自己身份的信息 提示保存秘钥的文件位置，直接回车保持默认位置 设置秘钥密码（直接回车则不设置秘钥密码），生成公钥、秘钥 完成之后可以在/root/.ssh/目录下找到公钥（id_rsa.pub）秘钥（id_rsa） 将公钥添加到git上复制id_rsa.pub的内容出来 打开github，进入需要拉取文件的仓库，进入设置标签页 点击Add Deploy key 输入GitHub密码确认 刚添加的公钥是灰色的，还没有被使用 在bootstrap.yml中配置把id_rsa的全部内容复制出来，放到private-key属性 注意： uri要用ssh形式的地址 ignore-local-ssh-settings设置为true，忽略本地的ssh配置 passphrase内要配置上面设置的秘钥密码 启动项目后，可以在Github的仓库设置中看到公钥已经被使用，变成了绿色。 至此spring-cloud-config使用ssh连接git就配置完成。 修改秘钥密码打开Git Bash/Terminal，输入ls-al ~/.ssh 检查之前是否已经生成了SSH key 如果是这样的那就说明已经生成过秘钥，可以选择修改修改私钥密码（passphrase）输入 ssh-keygen -p 直接回车继续，输入旧密码，然后输入两次新密码]]></content>
      <categories>
        <category>Java</category>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
