<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[千万级数据拆分与迁移]]></title>
    <url>%2Fposts%2F47bc30b3%2F</url>
    <content type="text"><![CDATA[​ 将数据从一张表中迁移到另一张表中，在数据量少的情况下很容易实现，而且方法也有很多，但当数据量到了百万、千万级时，不同方法在效率上会有很大差别。 业务场景项目在运行时会存储实时数据，主表每秒插入2,3条数据，一条主数据对应10条左右明细数据，现在数据库中，主表1千万条，明细8千万；需求是要根据主表中的type字段进行分类，将主表和明细表拆再拆出2张表。 实现项目在运行，实时会有数据存入，所以分为3个阶段；原表alarm为主表，alarm_detail为明细表； 1、将数据按类型从原表中导出为文件，再导入到对应的新建表中 2、项目暂停，执行替换sql，更新代码，重启项目 3、将在导入导出期间产生的数据再次按类型插入到新表中 一、项目正常运行，代码未更新复制alarm 与 alarm_detail 表12CREATE TABLE alarm_copy1 LIKE alarm;CREATE TABLE alarm_detail_copy1 LIKE alarm_detail; 新建alarm_2表与明细表alarm_2_detail12345678910111213141516CREATE TABLE `alarm_2` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `alarmId` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &apos;告警Id&apos;, `type` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `alarmId`(`alarmId`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &apos;主表&apos; ROW_FORMAT = Dynamic;CREATE TABLE `alarm_2_detail` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `iotId` bigint(20) NOT NULL, `paramValue` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, INDEX `iotId`(`iotId`) USING BTREE, CONSTRAINT `fk_iotId` FOREIGN KEY (`iotId`) REFERENCES `alarm_2` (`id`) ON DELETE CASCADE) ENGINE = InnoDB AUTO_INCREMENT = 0 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &apos;明细表&apos; ROW_FORMAT = Compact; 获取原表主键最大id1SELECT @maxId:=MAX(id) FROM alarm; 导出出A类型主数据，再导入新表FIELDS TERMINATED BY &#39;,&#39;表示字段间用,分割 OPTIONALLY ENCLOSED BY &#39;&quot;&#39;表示所有字符用&quot;包裹 ESCAPED BY &#39;*&#39;表示用*代表转义字符 LINES TERMINATED BY &#39;\r\n&#39;表示每条数据用空格加回车结束 123SELECT * FROM alarm WHERE id&lt;@maxId AND type=&apos;A&apos; INTO OUTFILE &apos;alarm_2.txt&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;*&apos; LINES TERMINATED BY &apos;\r\n&apos;;#导入LOAD DATA INFILE &apos;alarm_2.txt&apos; INTO TABLE alarm_2 FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;*&apos; LINES TERMINATED BY &apos;\r\n&apos;; 导出出A类型明细数据，再导入新表12SELECT ad.* FROM alarm_detail ad WHERE EXISTS (SELECT iotId FROM alarm a WHERE ad.iotId=a.id) INTO OUTFILE &apos;alarm_2_detail.txt&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;*&apos; LINES TERMINATED BY &apos;\r\n&apos;;LOAD DATA INFILE &apos;alarm_2_detail.txt&apos; INTO TABLE alarm_2_detail FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;*&apos; LINES TERMINATED BY &apos;\r\n&apos;; 导出出B类型主数据，再导入copy表12SELECT * FROM alarm WHERE id&lt;@maxId AND type=&apos;A&apos; INTO OUTFILE &apos;alarm_copy1.txt&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;*&apos; LINES TERMINATED BY &apos;\r\n&apos;;LOAD DATA INFILE &apos;alarm_copy1.txt&apos; INTO TABLE alarm_copy1 FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;*&apos; LINES TERMINATED BY &apos;\r\n&apos;; 导出出B类型明细数据，再导入新表12SELECT ad.* FROM alarm_detail ad WHERE EXISTS (SELECT iotId FROM alarm_copy1 ac WHERE ac.iotId=ad.id) INTO OUTFILE &apos;alarm_detail_copy1.txt&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;*&apos; LINES TERMINATED BY &apos;\r\n&apos;;LOAD DATA INFILE &apos;alarm_detail_copy1.txt&apos; INTO TABLE alarm_detail_copy1 FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;*&apos; LINES TERMINATED BY &apos;\r\n&apos;; 二、项目暂停、更新代码项目需要暂停几分钟，修改表名并更新代码 修改表名称将*_copy1表名与原表互换 123456ALTER TABLE alarm RENAME TO alarm_temp;ALTER TABLE alarm_detail RENAME TO alarm_detail_temp;ALTER TABLE alarm_copy1 RENAME TO alarm;ALTER TABLE alarm_detail_copy1 RENAME TO alarm_detail;ALTER TABLE alarm_temp RENAME TO alarm_copy1;ALTER TABLE alarm_detail_temp RENAME TO alarm_detail_copy1; 修改自增数为了保证在新数据插入新表后不会与暂未拆分数据主键冲突，需要将所有表的自增值改为原表自增数大小， 1234567891011#创建存储过程修改自增值DROP PROCEDURE IF EXISTS copy_auto_increment;CREATE PROCEDURE `copy_auto_increment`(IN `sourceTable` varchar(50),IN `targetTable` varchar(50))BEGIN DECLARE num BIGINT; DECLARE alterSql VARCHAR(250); SELECT AUTO_INCREMENT INTO num FROM information_schema.tables WHERE table_name = sourceTable AND table_schema = DATABASE(); SET num=num+100; SET alterSql=CONCAT(&apos;ALTER TABLE &apos;,targetTable,&apos; AUTO_INCREMENT=&apos;,num); EXECUTE alterSql;END; 修改alarm、alarm_detail、alarm_2、alarm_2_detail的自增数（大于原表目前的自增数值即可） 12345#调用CALL copy_auto_increment(&apos;iot_alarm_copy1&apos;,&apos;iot_alarm&apos;);CALL copy_auto_increment(&apos;iot_alarm_copy1&apos;,&apos;iot_alarm_fault&apos;);CALL copy_auto_increment(&apos;iot_alarm_detail_copy1&apos;,&apos;iot_alarm_detail&apos;);CALL copy_auto_increment(&apos;iot_alarm_detail_copy1&apos;,&apos;iot_alarm_detail_fault&apos;); 查询已拆分数据的最大id,并记录1234SELECT @maxId:=MAX(a.id) MAXId FROM(SELECT MAX(id) id FROM iot_alarmUNIONSELECT MAX(id) id FROM iot_alarm_fault)a; 三、代码更新完成，项目启动现在在*_copy1表中还有未拆分的数据，现在再进行拆分 创建拆分存储过程123456789101112131415161718192021222324252627282930DROP PROCEDURE IF EXISTS post_alarm_split;CREATE PROCEDURE `post_alarm_split`(IN `maxId` bigint)BEGIN -- 定义接收游标数据的变量 DECLARE done BOOLEAN DEFAULT 0; DECLARE var_id BIGINT DEFAULT 0; DECLARE var_alarmId VARCHAR(50); DECLARE var_type VARCHAR(50); DECLARE cur_alarm CURSOR FOR (SELECT id,alarmId,type FROM iot_alarm_copy1 WHERE id&gt;=maxId ORDER BY id); #退出标志 DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done = 1 ; OPEN cur_alarm; REPEAT FETCH cur_alarm INTO var_id,var_alarmId,var_type; IF NOT done THEN #A类 IF var_type=&apos;A&apos; THEN INSERT INTO alarm_2 VALUES(var_id,var_alarmId,var_type); INSERT INTO alarm_2_detail (SELECT id,iotId,paramValue FROM alarm_detail_copy1 WHERE iotId = var_id); #B类 ELSE INSERT INTO alarm VALUES(var_id,var_alarmId,var_type); INSERT INTO alarm_detail (SELECT id,iotId,paramValue FROM alarm_detail_copy1 WHERE iotId = var_id); END IF; END IF; UNTIL done END REPEAT; CLOSE cur_alarm;END; 执行拆分@maxId为之前已拆分过数据的最大主键id+1 12#后置拆分CALL post_alarm_split(@maxId); 总结1、这种拆分方式适合主键id自增的情况 2、项目重启后的拆分也可以使用导入导出的方式拆，重点是记录好已拆分的id 3、利用导出导入的方式可以大大提高数据迁移的效率 4、如果预计某些表数据量会很大时，可以考虑在表创建时就进行分区、或分表 备注导出时生成的文件在mysql的Data目录下，可以删除，节省服务器存储空间]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti6.0流程模型导入]]></title>
    <url>%2Fposts%2F73fc1757%2F</url>
    <content type="text"><![CDATA[Activiti是一个开源的工作流程引擎，而在流程引擎上执行的便是符合BPMN2.0规范的流程模型。在我们系统集成Activiti后，自然需要提供流程模型的导入功能。 导入模型思路：后台接受前端传来的文件，读取为XML文件，然后转为BpmnModel，再获取其中的流程数据，最后保存为Model。 POJO123456789101112/** * 流程模型基本参数 */@Datapublic class ModelParam&#123; @ApiModelProperty(value = "模型名称",required = true) private String name; @ApiModelProperty(value = "模型key",required = true) private String key; @ApiModelProperty("模型描述") private String description;&#125; controller12345678910@PostMapping("model/import")@ApiOperation(value = "导入模型")@ResponseBodypublic AjaxResult importModel(HttpServletRequest request)&#123;List&lt;MultipartFile&gt; file = ((MultipartHttpServletRequest) request).getFiles("file"); if (Collections.isEmpty(file))&#123; throw new CustomException("文件为空，上传失败！"); &#125; return modelService.importModelFiles(file);&#125; ServiceImpl12345678910111213141516171819202122232425262728293031323334353637383940@Override@Transactional(rollbackFor = Exception.class)public AjaxResult importModelFiles(List&lt;MultipartFile&gt; modelFiles) &#123; try &#123; for (MultipartFile modelFile : modelFiles) &#123; byte[] bytes = modelFile.getBytes(); String xml = new String(bytes, Charsets.UTF_8); //创建转换对象 BpmnXMLConverter converter = new BpmnXMLConverter(); XMLInputFactory factory = XMLInputFactory.newInstance(); // 字节方式 XMLStreamReader reader = factory.createXMLStreamReader(new ByteArrayInputStream(xml.getBytes())); //将xml文件转换成BpmnModel BpmnModel bpmnModel = converter.convertToBpmnModel(reader); //流程数据 Process process = bpmnModel.getMainProcess(); String modelKey = process.getId(); //判断导入的模型key是否重复 List&lt;Model&gt; modelList = repositoryService.createModelQuery().modelKey(modelKey).list(); if (CollectionUtils.isNotEmpty(modelList)) &#123; return AjaxResult.error(modelFile.getOriginalFilename() + "，模型Key已存在，导入失败！"); &#125; ModelParam modelParam = new ModelParam(); modelParam.setKey(process.getId()); modelParam.setName(process.getName()); modelParam.setDescription(process.getDocumentation()); //创建模型 String modelId =this.createModel(modelParam); //转为json格式保存 BpmnJsonConverter jsonConverter = new BpmnJsonConverter(); ObjectNode jsonNodes = jsonConverter.convertToJson(bpmnModel); repositoryService.addModelEditorSource(modelId, jsonNodes.toString().getBytes(Charsets.UTF_8)); &#125; &#125; catch (IOException | XMLStreamException e) &#123; logger.error("模型导入异常：&#123;&#125;", e.getMessage()); throw new CustomException("导入异常,请联系管理员！"); &#125; return AjaxResult.success("导入成功！");&#125; 123456789101112131415161718192021222324/*** 创建模型*/private String createModel(ModelParam modelParam) &#123; if (StringUtils.isBlank(modelParam.getKey()) || StringUtils.isBlank(modelParam.getName())) &#123; return AjaxResult.error("参数错误，模型创建失败！"); &#125; List&lt;Model&gt; list = this.repositoryService.createModelQuery().modelKey(modelParam.getKey()).list(); if (CollectionUtils.isNotEmpty(list)) &#123; return AjaxResult.error("模型Key重复!"); &#125; Model model = this.repositoryService.newModel(); ObjectNode modelNode = objectMapper.createObjectNode(); modelNode.put(ModelDataJsonConstants.MODEL_NAME, modelParam.getName()); modelNode.put(ModelDataJsonConstants.MODEL_DESCRIPTION, modelParam.getDescription()); modelNode.put(ModelDataJsonConstants.MODEL_REVISION, 1); model.setName(modelParam.getName()); model.setKey(modelParam.getKey()); model.setMetaInfo(modelNode.toString()); this.repositoryService.saveModel(model); this.createObjectNode(model); logger.info("创建模型结束，返回模型ID：&#123;&#125;", model.getId()); return model.getId();&#125; 1234567891011121314151617181920212223242526/** * 创建模型时完善ModelEditorSource * * @param model */@SuppressWarnings("deprecation")private void createObjectNode(Model model) &#123; logger.info("创建模型完善ModelEditorSource入参模型ID：&#123;&#125;", model.getId()); ObjectNode editorNode = objectMapper.createObjectNode(); editorNode.put("id", "canvas"); editorNode.put("resourceId", "canvas"); ObjectNode stencilSetNode = objectMapper.createObjectNode(); stencilSetNode.put("namespace", "http://b3mn.org/stencilset/bpmn2.0#"); ObjectNode propertiesNode = objectMapper.createObjectNode(); propertiesNode.put("process_id", model.getKey()); propertiesNode.put("name", model.getName()); editorNode.put("properties", propertiesNode); editorNode.put("stencilset", stencilSetNode); try &#123; this.repositoryService.addModelEditorSource(model.getId(), editorNode.toString().getBytes(Charsets.UTF_8)); &#125; catch (Exception e) &#123; logger.info("创建模型时完善ModelEditorSource服务异常：&#123;&#125;", e); throw new CustomException("模型创建失败"); &#125; logger.info("创建模型完善ModelEditorSource结束");&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Activiti6.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写一个简单的EasyExcel枚举类转换器]]></title>
    <url>%2Fposts%2Fa0a2f7b9%2F</url>
    <content type="text"><![CDATA[最近项目中用到了阿里的EasyExcel，一个简单方便读写excel的工具。 需求场景在项目中会定义一些枚举类来保存一些状态值，在存储进数据库时保存的是code,而我们在生成excel时需要展示对应的值。 代码实现原需要写入excel的对象 123456789@Datapublic class TestExcel &#123; /** * 状态 */ @ExcelProperty(value = "状态",converter = StatusEnumConvert.class) private String status;&#125; 枚举类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public enum StatusEnum &#123; WAIT_COMMIT("1","待提交"), WAIT_AUDIT("2","待审核"), AUDITED("3","已审核"), RETURNED("4","已退回"); private final String code; private final String info; StatusEnum(String code, String info) &#123; this.code = code; this.info = info; &#125; public String getCode() &#123; return code; &#125; public String getInfo() &#123; return info; &#125; /** * 根据code获取info */ public static String getInfoByCode(String code)&#123; for (StatusEnum statusEnum : StatusEnum.values()) &#123; if (statusEnum.getCode().equals(code))&#123; return statusEnum.getInfo(); &#125; &#125; return null; &#125; public static String getCodeByInfo(String info)&#123; for (StatusEnum statusEnum : StatusEnum.values()) &#123; if (statusEnum.getInfo().equals(info))&#123; return statusEnum.getCode(); &#125; &#125; return null; &#125;&#125; 转换器 1234567891011121314151617181920212223public class StatusEnumConvert implements Converter&lt;String&gt; &#123; @Override public Class supportJavaTypeKey() &#123; return String.class; &#125; @Override public CellDataTypeEnum supportExcelTypeKey() &#123; return CellDataTypeEnum.STRING; &#125; @Override public String convertToJavaData(CellData cellData, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123; String info = cellData.toString(); return StatusEnum.getCodeByInfo(info); &#125; @Override public CellData convertToExcelData(String s, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123; return new CellData(Objects.requireNonNull(StatusEnum.getInfoByCode(s))); &#125;&#125; 应网友反馈，使用注解和反射改进了转换器，提高复用性； 改进后先自定义一个注解 12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface TargetEnum &#123; Class&lt;? extends Enum&gt; targetEnum();&#125; 需要转换的枚举类 不再需要getCodeByInfo()与getInfoById()方法 12345678910111213141516171819202122232425public enum StatusEnum implements GetEnum &#123; WAIT_COMMIT("1","待提交"), WAIT_AUDIT("2","待审核"), AUDITED("3","已审核"), RETURNED("4","已退回"); private final String code; private final String info; StatusEnum(String code, String info) &#123; this.code = code; this.info = info; &#125; public String getCode() &#123; return code; &#125; public String getInfo() &#123; return info; &#125;&#125; 需要写入excel的对象 1234567@Datapublic class TestExcel &#123; //加上自定义注解，并写上对应的枚举类作为参数 @TargetEnum(targetEnum = StatusEnum.class) @ExcelProperty(value = "状态",converter = StatusEnumConverter.class) private String status;&#125; 修改后的转换器 利用反射获取字段上注解的枚举类型，然后调用get..()方法取值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class StatusEnumConverter implements Converter&lt;String&gt; &#123; @Override public Class supportJavaTypeKey() &#123; return String.class; &#125; @Override public CellDataTypeEnum supportExcelTypeKey() &#123; return CellDataTypeEnum.STRING; &#125; @Override public String convertToJavaData(CellData cellData, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123; String code=""; String info = cellData.toString(); Field field = excelContentProperty.getField(); TargetEnum annotation = field.getDeclaredAnnotation(TargetEnum.class); Class clazz = annotation.targetEnum(); Object[] enumConstants = clazz.getEnumConstants(); Method getInfo = clazz.getMethod("getInfo"); Method getCode = clazz.getMethod("getCode"); for (Object enumConstant : enumConstants) &#123; if (getInfo.invoke(enumConstant, null).equals(info)) &#123; code = (String) getCode.invoke(enumConstant, null); break; &#125; &#125; return code; &#125; @Override public CellData convertToExcelData(String s, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123; String info = ""; Field field = excelContentProperty.getField(); TargetEnum annotation = field.getDeclaredAnnotation(TargetEnum.class); Class clazz = annotation.targetEnum(); Object[] enumConstants = clazz.getEnumConstants(); Method getInfo = clazz.getMethod("getInfo"); Method getCode = clazz.getMethod("getCode"); for (Object enumConstant : enumConstants) &#123; if (getCode.invoke(enumConstant, null).equals(s)) &#123; info = (String) getInfo.invoke(enumConstant, null); break; &#125; &#125; return new CellData(info); &#125;&#125; 调用 1EasyExcel.write(filePath,TestExcel.class).sheet("枚举转换器").doWrite(dataList()); 效果]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用微信测试账号实现web端扫码登录]]></title>
    <url>%2Fposts%2F78864db2%2F</url>
    <content type="text"><![CDATA[一般网站应用使用微信扫码登录使用的是微信开放平台的接口，但注册开放平台需要提供企业信息，而且开放平台并没有提供测试账号，个人想要直接通过开放平台实现微信授权登录是不可行的。 微信在公众号中提供了测试账号，我们可以通过公众号实现微信授权； 准备工作1.申请微信公众号测试账号 2.设置授权回调页面地址 3.内网穿透 ​ 可以使用natapp实现内网穿透 4.引入依赖 12345&lt;!--WeChat公众号--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;weixin-java-mp&lt;/artifactId&gt;&lt;/dependency&gt; 代码实现jsp页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %&gt;&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/jquery-1.8.3.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/jquery.qrcode.min.js"&gt;&lt;/script&gt; &lt;script&gt; //二维码边长 var CODE_SIDE=200; var timer; $(function () &#123; reload_qrCode(); &#125;); //重新加载二维码 function reload_qrCode() &#123; //清空上次生成的二维码 $("#qrcode").html(""); //清除定时器 clearInterval(timer); $.get("$&#123;pageContext.request.contextPath&#125;/wx/authorization?" + new Date(), function (data) &#123; console.info(data.url); //生成二维码 $("#qrcode").qrcode(&#123; render: "canvas", width: CODE_SIDE, height: CODE_SIDE, text: data.url &#125;); add_icon("Wechat.png",72,88); timer = setInterval(function () &#123; ajax_wx_login_status(data.uuid); &#125;, 1000); &#125;,"json"); &#125; //轮询登录状态 function ajax_wx_login_status(uuid) &#123; $.post("$&#123;pageContext.request.contextPath&#125;/wx/checkLogin", &#123;uuid: uuid&#125;, function (res) &#123; if (res.status == 200) &#123; //登录状态200，登录成功 //进行相应业务代码的编写，或者直接进行页面跳转. //alert("登录成功"); clearInterval(timer); window.location.href = "$&#123;pageContext.request.contextPath&#125;/index"; //页面跳转 &#125;if (res.status==402)&#123; clearInterval(timer); console.info("二维码过期"); var context = $("#qrcode canvas")[0].getContext('2d'); context.fillStyle='rgba(160, 160, 160, 0.8)'; context.fillRect(0,0,CODE_SIDE,CODE_SIDE); context.fillStyle='rgba(0, 0, 0)'; add_icon("reload.png",48,41); context.font="14px Arial"; context.fillText("二维码过期,请刷新",45,140); &#125; &#125;, "JSON"); &#125; //在二维码中间加入微信图标 function add_icon(image_name, height, width) &#123; var image = new Image(); image.src="$&#123;pageContext.request.contextPath&#125;/images/"+image_name; var context = $("#qrcode canvas")[0].getContext('2d'); $(image).load(function()&#123; context.drawImage(image,(CODE_SIDE-width)/2,(CODE_SIDE-height)/2); &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="qrcode" onclick="reload_qrCode()"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; controller 前端发起请求到后端，后端生成带uuid的授权链接，返回链接与uuid到前端页面，并将uuid作为key存入redis中，前端页面生成二维码，用户扫描二维码，授权登录，微信回调当前接口传来uuid与code，通过code再调用微信接口获得用户信息，将用户的openid或者user对象作为value保存到redis和数据库中，前端获得二维码图片后轮询redis，查看redis中是否有user对象或openid，有则跳转，实现扫码登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137@Controller@RequestMapping("/wx")@Slf4j@PropertySource(value = "classpath:conf/wx.properties", ignoreResourceNotFound = true)public class WxController &#123; @Autowired private WxMpService wxMpService; @Autowired private JedisClient jedisClient; @Autowired private BuyerService buyerService; /** * redis中保存登录用uuid的前缀 */ private static final String REDIS_LOGIN_UUID_PRE = "LOGIN_UUID"; /** * uuid有效时长/二维码有效期 */ private static final int LOGIN_EXPIRE = 15; /** * 外网地址 */ @Value("XXXXXXX.nat300.top") private String URL; @GetMapping("/portal") @ResponseBody public String portal(String echostr, String timestamp, String nonce, String signature) &#123; log.info("WeChat校验"); if (!wxMpService.checkSignature(timestamp, nonce, signature)) &#123; // 消息签名不正确，说明不是公众平台发过来的消息 log.warn("非法请求"); return "false"; &#125; if (StringUtils.isNotBlank(echostr)) &#123; // 说明是一个仅仅用来验证的请求，回显echostr log.info(echostr); return echostr; &#125; log.warn("未知请求"); return null; &#125; /** * 生成用户授权链接 */ @GetMapping(value = "/authorization", produces = "application/json;charset=UTF-8") @ResponseBody public String authorization() &#123; String url = URL + "/wx/getUserInfo"; String UUIDParam = UUID.randomUUID().toString().replace("-", ""); url = url + "/" + UUIDParam; String authorizationUrl = wxMpService.oauth2buildAuthorizationUrl(url, WxConsts.OAuth2Scope.SNSAPI_USERINFO, null); log.info("authorizationUrl:" + authorizationUrl); String json = "&#123;\"uuid\":\"" + UUIDParam + "\",\"url\":\"" + authorizationUrl + "\"&#125;"; //将uuid存到redis,默认值为NULL jedisClient.set(REDIS_LOGIN_UUID_PRE + ":" + UUIDParam + ":BASE", "NULL"); //设置有效时长 jedisClient.expire(REDIS_LOGIN_UUID_PRE + ":" + UUIDParam + ":BASE", LOGIN_EXPIRE); return json; &#125; /** * 用户扫码回调的方法，获得用户信息 * * @param code */ @GetMapping(value = "/getUserInfo/&#123;uuid&#125;") public String getUserInfo(String code, @PathVariable String uuid, Model model) &#123; if (StringUtils.isBlank(uuid) || StringUtils.isBlank(code)) &#123; model.addAttribute("result", GMResult.build(400, "登录失败")); return "wx/loginStats"; &#125; System.out.println(uuid); String redisPre = REDIS_LOGIN_UUID_PRE + ":" + uuid + ":BASE"; log.info("code:" + code); try &#123; //code只能用一次,再次使用会抛异常 WxMpOAuth2AccessToken token = wxMpService.oauth2getAccessToken(code); WxMpUser wxMpUser = wxMpService.oauth2getUserInfo(token, null); //检查是否存在 if (!jedisClient.exists(redisPre)) &#123; model.addAttribute("result", GMResult.build(402, "二维码已过期")); return "wx/loginStats"; &#125; //当redis中对应uuid未被使用 if ("NULL".equals(jedisClient.get(redisPre))) &#123; //将用户信息保存到redis中 jedisClient.set(redisPre, JsonUtils.objectToJson(wxMpUser)); //设置有效时长 jedisClient.expire(redisPre, LOGIN_EXPIRE); log.info(wxMpUser.toString()); model.addAttribute("result", GMResult.build(200, "登录成功")); return "wx/loginStats"; &#125; &#125; catch (WxErrorException e) &#123; e.printStackTrace(); model.addAttribute("result", GMResult.build(401, "请勿重复登录")); return "wx/loginStats"; &#125; model.addAttribute("result", GMResult.build(403, "二维码已使用")); System.out.println("登录失败"); return "wx/loginStats"; &#125; /** * 查询用户是否授权 * * @param uuid * @param session * @return */ @PostMapping(value = "/checkLogin", produces = "application/json;charset=UTF-8") @ResponseBody public GMResult checkLogin(String uuid, HttpSession session) &#123; String redisPre=REDIS_LOGIN_UUID_PRE + ":" + uuid + ":BASE"; //根据uuid查询redis中是否存在用户且授权 if (!jedisClient.exists(redisPre))&#123; return GMResult.build(402, "二维码已过期"); &#125; String json = jedisClient.get(redisPre); System.out.println("等待登录。。。。。json:" + json); if (!"NULL".equals(json)) &#123; //如果值不为默认值，转成user对象 WxMpUser wxMpUser = JsonUtils.jsonToPojo(json, WxMpUser.class); System.out.println(wxMpUser.toString()); Buyer buyer=buyerService.wxLogin(wxMpUser); //存在则跳转到登录成功页，并将user放入session中 session.setAttribute("user", buyer); return GMResult.ok(); &#125; //否则返回false return GMResult.build(400, "登录失败"); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA中自定义骨架（archetype）]]></title>
    <url>%2Fposts%2Fceb2a2ec%2F</url>
    <content type="text"><![CDATA[IDEA中可以使用archetype快速生成一个项目骨架，但自带的archetype太精简了，并不一定合适我们，我们可以自定义一个合适我们的骨架。 创建archetype创建一个maven项目可以使用已存在的archetype，也可以不使用 修改项目可以在创建的项目中加入复用性高的配置与依赖（下面是以web项目为例） 注意：包内要有文件占位，否则在生成archetype时会丢弃这个包 生成archetype在IDEA中按Alt + F12，打开Terminal视图，直接进入当前项目的根目录，输入mvn archetype:create-from-project 创建archetype 执行完后会出现target目录 安装archetype执行cd target\generated-sources\archetype进入创建的archetype 项目目录 执行mvn clean install安装archetype 生成记录文件(可选)，执行mvn archetype:crawl 执行完后可以在本地仓库里找到生成的archetype-catalog.xml文件 打开这个文件，可以看到我们自定义的archetype信息 将archetype加入IDEA在IDEA中进入New Project界面，选择Add Archetype，填入我们的archetype信息，点击ok 到这就完成了在IDEA中自定义archetype了，以后就可以在创建项目时直接选中使用了。 删除IDEA中自定义的archetype从本地仓库中删除archetype删除不再需要的archetype的文件夹 从IDEA中删除archetype打开目录C:/Users/(用户名)/.IntelliJIdea(版本号)/system/Maven/Indices 其中UserArchetypes.xml文件中记录了用户自定义的archetype，删除不需要的archetype所在行就搞定了。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用原生js实现轮播图]]></title>
    <url>%2Fposts%2F616%2F</url>
    <content type="text"><![CDATA[使用原生JS实现轮播图，下面先看看成品； 实现的效果 图片自动滑动切换，鼠标移动到图片上则停止切换； 鼠标移动到圆点时切换到相应的图片； 点击箭头切换到下一张图片； 鼠标离开图片，则隐藏箭头； 默认是3张图片，需要更多图片时，只需追加&lt;img&gt;标签; 实现逻辑将图片连接成条形，像胶卷一样，给个图片大小的窗口，左右移动图片条，完成切换； 实现代码HTML基本的HTML框架 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;link rel="stylesheet" href="css/slide.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;div id="pic_box"&gt; &lt;img src="img/arrow_left.png" id="arrow-left"&gt; &lt;img src="img/arrow_right.png" id="arrow-right"&gt; &lt;!--放圆点用--&gt; &lt;ul id="multi-circles"&gt;&lt;/ul&gt; &lt;div id="multi-images"&gt; &lt;img src="img/1.jpg"&gt;&lt;img src="img/2.jpg"&gt;&lt;img src="img/3.jpg"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="js/slide.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS使用绝对定位对各个元素布局。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*定义图片大小与默认图片数*/:root &#123; --imageWidth: 800px; --imageHeight: 240px; --imageNum: 3;&#125;.box &#123; margin: 0 auto; width: 800px;&#125;/*只显示图片大小的窗口展示单张图片*/#pic_box &#123; position: relative; width: var(--imageWidth); height: var(--imageHeight); overflow: hidden;&#125;/*绝对定位圆点的位置*/#multi-circles &#123; position: absolute; right: 30px; bottom: 10px; z-index: 2;&#125;/*设置圆点的格式并使圆点横排*/#multi-circles li &#123; width: 25px; list-style: none; font-size: 24px; float: left; color: white;&#125;/*设置计算图片条的长度*/#multi-images &#123; position: absolute; left: 0; top: 0; z-index: 1; width: calc(var(--imageWidth) * var(--imageNum)); height: var(--imageHeight); transition: 1s;&#125;/*设置左右箭头图标的位置*/#arrow-right, #arrow-left &#123; position: absolute; top: 50%; margin-top: -24px; height: 48px; z-index: 3; background: rgba(159, 180, 179, 0.38); display: none; cursor: pointer;&#125;#arrow-right &#123; right: 0;&#125;#arrow-left &#123; left: 0;&#125; JS核心步骤： 获取图片个数。 添加圆点。 设置“图片条”长度。 添加圆点、箭头的鼠标与点击事件； 设置图片轮播定时器； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//获得html组件var arrowLeft = document.getElementById("arrow-left");var arrowRight = document.getElementById("arrow-right");var multiImages = document.getElementById("multi-images");var circles = document.getElementById("multi-circles");var picBox = document.getElementById("pic_box");//图片个数var picNum = multiImages.getElementsByTagName("img").length;//根据图片数量添加圆点for (var i = 0; i &lt; picNum; i++) &#123; var liElement = document.createElement("li"); liElement.innerHTML = "●"; circles.appendChild(liElement);&#125;//在html设置图片数量document.documentElement.style.setProperty("--imageNum", picNum);//获取css中设置的图片宽度var imageWidth = getComputedStyle(document.documentElement).getPropertyValue("--imageWidth");imageWidth = imageWidth.substring(0, imageWidth.indexOf("px"));//设置轮播图片总长度multiImages.style.width = picNum * imageWidth + "px";//获取li列表对象circles = document.getElementById("multi-circles").getElementsByTagName("li");//最大下标var maxIndex = picNum - 1;//当前图片的序号var currentIndex = 0;//为箭头和圆点绑定事件arrowLeft.addEventListener("click", preMove);arrowRight.addEventListener("click", nextMove);for (var i = 0; i &lt; circles.length; i++) &#123; circles[i].setAttribute("id", i); circles[i].addEventListener("mouseenter", overCircle);&#125;//第一次载入，第一个圆是红色circles[0].style.color = "#ff0000";//定时器，每2秒移动var time = setInterval(nextMove, 2000);//滑过圆点function overCircle() &#123; var preIndex = currentIndex; currentIndex = parseInt(this.id); moveImage(); changeCircleColor(preIndex, currentIndex)&#125;//左箭头function preMove() &#123; var preIndex = currentIndex; if (currentIndex !== 0) &#123; currentIndex--; &#125; else &#123; currentIndex = maxIndex; &#125; moveImage(); changeCircleColor(preIndex, currentIndex)&#125;//右箭头function nextMove() &#123; var preIndex = currentIndex; if (currentIndex !== maxIndex) &#123; currentIndex++; &#125; else &#123; currentIndex = 0; &#125; moveImage(); changeCircleColor(preIndex, currentIndex)&#125;//移动图片function moveImage() &#123; multiImages.style.left = -currentIndex * imageWidth + "px";&#125;//改变圆点颜色function changeCircleColor(preIndex, currentIndex) &#123; circles[preIndex].style.color = "#ffffff"; circles[currentIndex].style.color = "#ff0000"&#125;//鼠标移动到图片上时显示箭头picBox.addEventListener("mouseover", function (ev) &#123; arrowRight.style.display = "block"; arrowLeft.style.display = "block"; clearInterval(time);&#125;);//鼠标离开图片上时隐藏箭头picBox.addEventListener("mouseleave", function (ev) &#123; arrowRight.style.display = "none"; arrowLeft.style.display = "none"; time = setInterval(nextMove, 2000);&#125;); 遇到的bug 第二张图片显示不完整，而且左边有白边，而第三张图片不显示。 在浏览器中检查发现两张图片之间有缝隙，导致第三张图片被强行换行，看起来第三张图片位置空白；尝试设置bored、margin、padding为0，并没有效果。看看HTML，看起来没什么问题； 解决办法：将&lt;img&gt;标签间的回车去掉，写成一行；或者将图片设置为左浮动，style=&quot;display:block; float:left&quot;； 原因：&lt;img&gt;标签是行内元素，默认排版为 inline-block；而所有的inline-block元素之间都会有空白。 在获取css文件中设置的图片宽高时，“获取”不到值； 使用document.documentElement.style.getPropertyValue(&quot;--imageWidth&quot;);得到的值为空； 解决办法：改用getComputedStyle(document.documentElement).getPropertyValue(&quot;--imageWidth&quot;);才能拿到:root选择器中设置的值； 原因： document.documentElement.style.getPropertyValue只能获取内联式样的值；而getComputedStyle(document.documentElement).getPropertyValue获取到的始终是实际的值; 注意事项轮播图默认大小为800*240，图片大小一致时无需修改任何css、js；使用自定义大小的图片时需要修改css文件中:root中--imageWidth、--imageHeight的值； 参考链接css变量赋值和取值的四种方式 原生JS实现滑动轮播图]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>轮播图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中Map、Collection接口常用实现类源码浅析]]></title>
    <url>%2Fposts%2F43684%2F</url>
    <content type="text"><![CDATA[在Java中集合是常用的数据结构，而Map与Collection的实现类有很多，我们常见的有HashMap、HashTable、TreeMap、LinkedHashMap、ArrayList、Linkedlist、Vector、HashSet、TreeSet、LinkedHashSet； 下面从源码的层面简析这些实现类的特性； Map先看看Map接口的继承关系图 Map是顶级接口，声明了通用的抽象方法，如获取所有键值对的方法——entrySet；以及还有静态的内部接口Entry；使用entrySet遍历Map集合的方式效率高于使用keySet遍历方式；keySet会遍历两次集合，第一次将集合转为Iterator对象，第二次重hashMap中取出key所对应的entrySet；而entrySet只是遍历一次就把key和value放入了entry中。如果是在JDK8，使用Map.forEach方法更好。 values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。 AbstractMap抽象类AbstractMap实现了Map接口的”骨干”方法，目的是减少实现Map接口的时需要重写的方法。 如其中实现的keySet方法用于获得Map中的所有Key值Set集合，内部创建AbstractSet的匿名子类实例存放key值；实现的values方法中，创建了AbstractCollection匿名子类实例，用于存放map中value值； HashMapHashMap继承自AbstractMap并实现了Map等接口，HashMap中定义了名为Node的静态内部类，Node实现了Map.Entry接口，是一个单向链表，然后使用Node[]数组，完成了HashMap的存储结构（数组+链表/红黑树）。 HashMap中还定义了一个静态内部类，TreeNode，TreeNode继承自LinkedHashMap.Entry，TreeNode实现了红黑树数据结构。 在计算Key的Hash值时，如果Key为空，则Hash值为0 put()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public V put(K key, V value) &#123; //1.对Key计算Hash值 return putVal(hash(key), key, value, false, true); &#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //2.检查Hash表是否为空，如果是空则调用resize扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //3.计算下标，并检查是否存在，不存在则在数组中直接添加一个节点，并放入key，value if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //4.Hash值、key相同时，替换旧值 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //4.Hash值相同，Key不同时，则以链表的的方式连接到后面 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //5.如果链表长度超过阀值（TREEIFY_THRESHOLD=8），则把链表转换成红黑树 if (binCount &gt;= TREEIFY_THRESHOLD= - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //链表中包含要插入的键值对时，终止插入 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //判断要插入的值是否存在HashMap中 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //键值对数量超过阀值时扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 方法的入口是put(K,V)，但核心逻辑是在putVal(int, K k, V , boolean ,boolean)；核心做了以下工作： 计算下标 判断Hash表状态，表容量不够则扩容 查找要插入的键值对是否存在，不存在则直接放入，键相同时，用链表的方式连接到相应的Hash值后面 如果链表长度超过阈值，将链表转换成红黑树 如果键存在，则更新旧值 get()12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; //1.根据Key计算Hash值，再调用getNode方法 return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //2.节点数组判空，并根据Hash值找到头结点 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //3.检查头节点是否为要找的节点 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //4.遍历链表，找到节点并返回 if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; //5.找不到返回空 return null;&#125; get()方法相比put()更简单，先计算Hash值，再根据Hash值遍历后面的链表，调用Key.equals()方法进行匹配。 小结HashMap使用Hash表作为数据结构，线程不安全，键值可以为空，自定义对象作为键时，需要重写equals()和HashCode()方法;如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。 LinkedHashMapLinkedHashMap继承自HashMap，并实现了Map接口，其中定义的静态内部类Entry继承自HashMap.Node类，在Entry中定义了前后节点，实现了Hash表和双向链表数据结构。通过双向链表，保证了数据存取顺序一致。 TreeMapTreeMap继承自AbstractMap，直接实现了NavigableMap接口，NavigableMap是Map的间接子接口；TreeMap中定义的静态内部类Entry实现了Map.Entry接口，并添加了父、左右还有节点属性，实现了红黑树结构；TreeMap内部自动自然排序，如果要存储自定义对象需要创建比较器（实现Comparator接口）或自定义类实现Comparable接口，重写compareTo方法； HashtableHashtable继承自Dictionary，实现了Map接口。其中的私有静态内部类Entry实现了Map.Entry接口，并增加了增加了hash、key、value、next成员属性，实现了单向链表结构，再结合数组，实现了Hash表存储结构。 其中的public成员方法都使用了synchronized修饰，所以线程安全但效率相对较低。 键值都不可以为null。 Collection Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 AbstractCollectionAbstractCollection抽象类提供了Collection接口的骨干实现，减少子类需要实现的方法，如contains()； ListList接口继承自Collection接口，该接口下的实现类为有序列表，可以根据索引访问其中的元素，可以有多个null元素。 LinkedListLinkedList继承自AbstractCollection的子类AbstractSequentialList；LinkedList中定义了静态内部类Node，Node中定义了前驱与后继节点（Node），这实现了单向链表数据结构，单向链表的特性就是增删快。 get()先检查索引（下标）是否存在，不存在则抛出索引（下标）越界异常， 下标存在则调用node(inde)方法，这个方法会先判断下标是在前半还在是后半，在前半就从前往后遍历，在后半就从后往前遍历，这说明如果要找的索引在两头时，效率是很高的。 set()set()方法很简单，先根据索引遍历列表，获得Node后替换成新值。 add()add()方法被重载过，当只有一个参数时，直调用linkLast()将元素链接到链表最后面； 两个参数时，先判断是不是尾节点，是位节点直接调用linkLast()方法；不是尾节点则调用linkBefore()方法； 查找到索引值处的节点(node)，判断是不是头结点，最后就是链表的插入操作。 LinkedList线程不安全，查询慢。由于定义了表头与表尾元素，所以也可以当做堆栈、队列和双向队列使用。 ArrayListArrayList继承自AbstractList并实现了List等接口。通过ArrayList提供的构造方法可已看出来，ArrayList是通过数组实现的； get()get()方法直接是通过数组索引(下标)取值 set()set()方法也是通过通过数组索引(下标)直接赋值 add()两个add()方法在插入元素前都会对数组容量进行检查，容量不够时进行扩容；扩容完成后对数组进行复制； 扩容后的长度是之前长度的1.5倍+1。 ArrayList数据查询快，增删慢，线程不安全。 VectorVector继承自AbstractList并实现了List等接口；Vector与ArrayList基本一致，也是使用数组实现的；但是Vector的构造方法可以指定扩容参数 在扩容方法grow()中，默认扩展一倍大小，也可增加指定大小 Vector与ArrayList最大的区别是，Vector的public方法都使用了synchronized来实现线程安全，这就降低了Vector的速度。 SetSet接口也继承自Collection接口，Set的实现类是不包含重复元素的集合，最多只能包含一个null元素; TreeSetTreeSet继承自AbstractSet实现了Set的子孙接口(NavigableSet)，通过TreeSet的构造方法，可以发现，TreeSet内部是用TreeMap实现的，那么底层也是使用了二叉树做数据结构；自动内排序； add()add()方法其实调用的是Map的put()方法，map的key是需要存放的元素，而value是一个Object对象。这也是为什么TreeSet不能存放重复值得原因。 TreeSet中的其他方法内也是对Map方法的调用。TreeMap的key不可以为空，value可以为空； HashSetHashSet继承自AbstractSet并实现了Set等接口；通过构造方法，可以看出来，HashSet内部是使用HashMap实现的，底层也是使用了Hash表作为数据结构； add()HashSet的add()方法使用的是HashMap的put()方法； HashSet的其他方法也使用的是HashMap的响应方法进行封装。 小结HashSet不保证存取顺序一致，允许一个null，值唯一。 LinkedHashSetLinkedHashSet继承自HashSet，并实现了Set等接口；其构造方法直接调用了父类的3个参数的构造方法，在父类的构造方法中创建LinkedHashMap对象；可以看出来LinkedHashSet底层使用了链表加Hash表作为数据结构。既保证数据的存取顺序，也保证了值得唯一性；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式之桥接模式]]></title>
    <url>%2Fposts%2F2375%2F</url>
    <content type="text"><![CDATA[桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 简单来说，可以通过桥接模式实现使用相同的抽象方法、不同的桥接实现类获得不同的结果。 猪八戒转世成为猪，孙悟空是转世成为猴子，他们的“灵魂”是同类的，但“肉身”不同。下面用代码来模拟这种关系； 类继承/实现关系简图 具体实现 创建转世接口 1234public interface TurnAPI &#123; /** 转世肉体 */ public String body();&#125; 创建转世接口的实现类 123456public class Pig implements TurnAPI &#123; @Override public String body() &#123; return "猪！"; &#125;&#125; 123456public class Monkey implements TurnAPI &#123; @Override public String body() &#123; return "猴子！"; &#125;&#125; 创建抽象灵魂类 1234567891011121314151617public abstract class Soul &#123; /** 将TurnAPI作为属性注入Soul，这是实现桥接的关键 */ protected TurnAPI turnAPI; private String name; public Soul(String name, TurnAPI turnAPI) &#123; this.name = name; this.turnAPI=turnAPI; &#125; public String getName() &#123; return name; &#125; public abstract String body(); public abstract String type();&#125; 创建抽象灵魂类的子类 123456789101112131415public class God extends Soul&#123; public God(String name, TurnAPI turnAPI) &#123; super(name, turnAPI); &#125; @Override public String body() &#123; return turnAPI.body(); &#125; @Override public String type() &#123; return "神"; &#125;&#125; 123456789101112131415public class Monster extends Soul&#123; public Monster(String name, TurnAPI turnAPI) &#123; super(name, turnAPI); &#125; @Override public String body() &#123; return turnAPI.body(); &#125; @Override public String type() &#123; return "妖"; &#125;&#125; 创建测试类 12345678910public class Test &#123; public static void main(String[] args) &#123; Soul tianPeng = new God("猪八戒", new Pig()); Soul monkeyKing = new God("孙悟空", new Monkey()); Soul sixEar = new Monster("六耳猕猴", new Monkey()); System.out.println("灵魂：" + tianPeng.getName() + "，肉身：" + tianPeng.body()+"，属性："+tianPeng.type()); System.out.println("灵魂：" + monkeyKing.getName() + "，肉身：" + monkeyKing.body()+"，属性："+monkeyKing.type()); System.out.println("灵魂：" + sixEar.getName() + "，肉身：" + sixEar.body()+"，属性："+sixEar.type()); &#125;&#125; 执行结果 小结通过上面代码，实现了将猪八戒的灵魂放进了猪的肉体内，将孙悟空的灵魂放进了猴子的肉体内；灵魂的具体类也有妖和神的区别，上面也实现了将六耳猕猴的灵魂放进猴子肉体中，当然也可以放进猪内； 由上可知，桥接模式适用于两个独立变化的维度之间。通过桥接模式，我们可以将不同的实现类和不同的接口实现进行连接。使用桥接模式避免了抽象类实现接口，抽象与实现分离；由于桥接模式是在抽象层面建立关联关系，这也加大了系统的设计与理解难度。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Bridge Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式之适配器模式]]></title>
    <url>%2Fposts%2F21579%2F</url>
    <content type="text"><![CDATA[适配器模式（Adapter Pattern）是不兼容接口之间的桥梁，可以使一个类加入独立的或不兼容的接口功能。比如计算机通过适配器读取之前无法读取的TF卡；下面用Java模拟这一过程的实现； 计算机本身可以读取SD卡，通过适配器读取TF卡。 类继承/实现关系简图 具体实现 先创建个SD卡接口 1234567public interface SdCard &#123; /**读sd卡*/ String readSdCard(); /** 写sd卡*/ int writeSdCard(String msg);&#125; 创建SD卡接口的实现类，模拟SD卡功能 123456789101112public class SdCardImpl implements SdCard &#123; @Override public String readSdCard() &#123; return "欢迎使用Sd卡"; &#125; @Override public int writeSdCard(String msg) &#123; System.out.println("SD写入信息："+msg); return 1; &#125;&#125; 创建个计算机接口 1234567public interface Computer &#123; /**读取SD卡*/ String readSdCard(SdCard sdCard); /**写入sd卡*/ void writeSdCard(SdCard sdCard,String msg);&#125; 创建计算机接口的实现类，模拟计算机对SD卡的读写操作 12345678910111213141516171819public class MacComputer implements Computer &#123; @Override public String readSdCard(SdCard sdCard) &#123; if (sdCard == null) &#123; throw new NullPointerException("未放入sd卡！"); &#125; return sdCard.readSdCard(); &#125; @Override public void writeSdCard(SdCard sdCard, String msg) &#123; if (sdCard == null || msg.isEmpty()) &#123; throw new NullPointerException("写入sd卡失败！"); &#125; if (sdCard.writeSdCard(msg)==1) &#123; System.out.println("写入完成！"); &#125; &#125;&#125; 现在创建一个测试类，模拟计算机读取SD卡 12345678public class Test &#123; public static void main(String[] args) &#123; Computer macComputer = new MacComputer(); SdCard sdCard = new SdCardImpl(); System.out.println("读出信息："+macComputer.readSdCard(sdCard)); macComputer.writeSdCard(sdCard,"sd写入测试。。。"); &#125;&#125; 执行结果 计算机已经读取SD卡成功，下面在不改变计算机读取SD卡接口的前提下，使用适配器实现读取TF卡； 创建TF卡接口 1234567public interface TfCard &#123; /** 读Tf卡 */ String readTfCard(); /** 写入Tf卡*/ int writeTfCard(String msg);&#125; 创建TF卡接口的实现类，同样模拟TF卡功能 123456789101112public class TfCardImpl implements TfCard &#123; @Override public String readTfCard() &#123; return "欢迎使用TF卡"; &#125; @Override public int writeTfCard(String msg) &#123; System.out.println("TF写入信息："+msg); return 1; &#125;&#125; 创建SD适配TF的适配器 123456789101112131415161718192021public class SdAdapterTf implements SdCard &#123; /**将TfCard作为属性引入适配器*/ private TfCard tfCard; public SdAdapterTf(TfCard tfCard) &#123; this.tfCard = tfCard; &#125; @Override public String readSdCard() &#123; System.out.println("适配器读TF卡"); return tfCard.readTfCard(); &#125; @Override public int writeSdCard(String msg) &#123; System.out.println("适配器写TF卡"); tfCard.writeTfCard(msg); return 1; &#125;&#125; 测试，模拟计算机读取TF卡 12345678910111213public class Test &#123; public static void main(String[] args) &#123; Computer macComputer = new MacComputer(); SdCard sdCard = new SdCardImpl(); System.out.println("读出信息："+macComputer.readSdCard(sdCard)); macComputer.writeSdCard(sdCard,"sd写入测试。。。"); System.out.println("================================"); TfCard tfCard = new TfCardImpl(); SdAdapterTf sdAdapterTf = new SdAdapterTf(tfCard); System.out.println("读出信息："+macComputer.readSdCard(sdAdapterTf)); macComputer.writeSdCard(sdAdapterTf,"Tf写入测试"); &#125;&#125; 执行结果 小结因为不能改变computer类的SDCard接口，所以适配器需要实现SDCard接口，保证适配器能“插入”computer，而将TFCard作为私有属性引入适配器，实现了将TFCard插入适配器，通过以上过程，TF卡成功被计算机读取； 适配器模式是Java多态的完美体现，不仅拓展了功能，还对原有代码无侵入性。但是，适配器并不适合在程序设计时应用，因为当适配器变多后，对接口的调用不再清晰，如对接口A的调用，可能在A内调用了B接口，这将导致接口混乱。更好的使用情况是在系统正常运行时，为了兼容新接口而有机的使用。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Adapter Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA中常见的Icon代表什么意义]]></title>
    <url>%2Fposts%2F47185%2F</url>
    <content type="text"><![CDATA[在使用IDEA时发现有些Icon不知道是什么意思，什么时候会出现，下面是常遇到的一些Icon，在此记录一下。 摘自IntelliJ IDEA 2019.2官方帮助文档。 common Icon Description java编译后生成的字节码文件 抽象类 注解类 枚举类 异常类 final修饰的类 如String类 接口 含main()方法的类 测试用例 方法 抽象方法 字段（成员变量） 变量（局部变量） 参数 元素 目录 模块 模块组 包 源文件根目录 测试根目录 不编译的根目录，一般存放编译后的.class文件 资源根目录，一般存放配置文件和web页面相关文件如.ftl、.js、.css 测试用资源根目录 Visibility modifiers对类或方法的修饰符 Icon Description 只读的类，如引入的外部Jar包 私有的 受保护的 包内可访问的 静态的 公开的]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中使用Lambda表达式]]></title>
    <url>%2Fposts%2F38346%2F</url>
    <content type="text"><![CDATA[Lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。使用Lambda表达式的重点是延迟执行（deferred execution）。 语法123(Type param1,Type param2,Type param3) -&gt; &#123; //TODO&#125; 参数类型可以省略，编译器可以根据上下文推导；但并不是所有类型都能推导出来，有时需要声明参数类型； 当参数只有一个时，小/圆括号可以省略； 当主体只有一条语句时，大括号可以省略； 当主体只有一条语句时，return可以省略； 实例参考自runoob.com。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Java8Test &#123; public static void main(String[] args) &#123; Java8Test test = new Java8Test(); //函数式接口实例 //类型声明 MathOperation addition = (int a, int b) -&gt; a + b; //不用类型声明 MathOperation subtraction = (a, b) -&gt; a - b; //大括号中有返回语句 MathOperation multiplication = (a, b) -&gt; &#123; return a * b; &#125;; //没有大括号及返回语句 MathOperation division = (int a, int b) -&gt; a / b; //函数式编程，将函数作为参数传入一个方法 System.out.println("10+5=" + test.operate(10, 5, addition)); System.out.println("10-5=" + test.operate(10, 5, subtraction)); System.out.println("10*b=" + test.operate(10, 5, multiplication)); System.out.println("10/5=" + test.operate(10, 5, division)); //单个参数可以省略括号 GreetingService greetingService1 = message -&gt; System.out.println("Hello" + message); //不省略括号 GreetingService greetingService2 = (message) -&gt; System.out.println("Hello" + message); greetingService1.sayMessage("World"); greetingService2.sayMessage("Lambda"); &#125; interface MathOperation &#123; int operation(int a, int b); &#125; @FunctionalInterface interface GreetingService &#123; void sayMessage(String message); //void sayMessage(String name,String message); @Override String toString(); &#125; private int operate(int a, int b, MathOperation mathOperation) &#123; return mathOperation.operation(a, b); &#125;&#125; ​ 上面的实例中，将MathOperation接口（函数）做为参数传递给operate方法，返回的也是一个方法（函数），这在java 8 之前是无法做到的。这也是java 8的另一新特性，函数式编程；支持函数式编程的语言有很多，如Python、JavaScript等。 在java中Lambda表达式是对象，它必须依附于一类特别的对象类型——函数式接口（Functional Interface） ​ 函数式接口的定义：如果一个接口中，有且只有一个抽象的方法（Object类中的方法不包括在内），那这个接口就可以被看做是函数式接口。 ​ 回到上面的实例中，MathOperation接口与GreetingService接口都是函数式接口，其中GreetingService内重写了Object类的toString方法，注解@FunctionalInterface用于声明该接口为函数式接口，如果某个接口（如MathOperation）满足函数式接口定义，编译器也会认为这是一个函数式接口；函数式接口内的方法不可以重载； 变量作用域 Lambda 表达式只能引用声明为final的外层局部变量。 Lambda 表达式中使用局部变量时，该局部变量可以不用声明为final，但是必须不可被后面的代码修改（即隐性的具有final的语义）。 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 在 Lambda 表达式中使用this关键字时，是指创建这个Lambda表达式的方法的this参数。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>Java 8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 实现常见排序算法]]></title>
    <url>%2Fposts%2F59966%2F</url>
    <content type="text"><![CDATA[直接插入排序12345678def insertion_sort(arr): """直接插入排序""" for i in range(1, len(arr)): for j in range(0, i): if arr[i] &lt; arr[j]: arr.insert(j, arr.pop(i)) print("第&#123;&#125;轮排序后结果为：&#123;&#125;".format(i, arr)) return arr 快速排序123456789101112131415161718def quick_partition(arr, low, high): i = (low - 1) # 最小元素索引 pivot = arr[high] for j in range(low, high): # 当前元素小于或等于 pivot if arr[j] &lt;= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1def quick_sort(arr, low, high): """快速排序""" if low &lt; high: temp = quick_partition(arr, low, high) quick_sort(arr, low, temp - 1) quick_sort(arr, temp + 1, high) 选择排序1234567891011121314def select_sort(arr): """选择排序""" sort_list = [] min_index = 0 while len(arr) != 0: # 取出余下数列中最小的值的索引 for i in range(0, len(arr)): if arr[i] &lt; arr[min_index]: min_index = i # 将值取出放入新数组 sort_list.append(arr.pop(min_index)) # 归零索引 min_index = 0 return sort_list 冒泡排序1234567def bubble_sort(arr): """冒泡排序""" for t in range(len(arr) - 1): for i in range(len(arr) - 1 - t): if arr[i] &gt; arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr 归并排序1234567891011121314151617181920212223def merge_sort(arr): """归并排序""" # 计算中值 mid = len(arr) // 2 # 切割左右数组 left = arr[:mid] right = arr[mid:] merge = [] # 左边数组元素个数大于1时归并排序 if len(left) &gt; 1: left = merge_sort(left) # 右边数组元素个数大于1时归并排序 if len(right) &gt; 1: right = merge_sort(right) # 归并左右数组 while left and right: if right[0] &lt;= left[0]: merge.append(right.pop(0)) else: merge.append(left.pop(0)) merge.extend(left) merge.extend(right) return merge 堆排序123456789def heap_sort(arr): """堆排序""" result = [] while arr: # 初始化堆 arr = min_heap(arr) # 取出堆顶元素 result.append(arr.pop(0)) return result 建最小堆123456789101112131415161718192021def min_heap(arr): """建最小堆""" arr = list(arr) le = len(arr) mid = le // 2 for i in range(0, mid): temp = mid - i # 判断是否有右支 if 2 * temp == le: # 无右支，比较左支并交换 if arr[temp - 1] &gt; arr[temp * 2 - 1]: arr[temp - 1], arr[temp * 2 - 1] = arr[temp * 2 - 1], arr[temp - 1] else: # 比较左右支,并与父节点交换 if arr[temp * 2 - 1] &gt; arr[temp * 2]: min_index = temp * 2 else: min_index = temp * 2 - 1 if arr[temp - 1] &gt; arr[min_index]: arr[temp - 1], arr[min_index] = arr[min_index], arr[temp - 1] return arr 希尔排序1234567891011121314def shell_sort(arr): """希尔排序""" n = len(arr) gap = n // 2 while gap &gt; 0: for i in range(gap, n): temp = arr[i] j = i while j &gt;= gap and arr[j - gap] &gt; temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap = gap // 2 return arr]]></content>
      <categories>
        <category>Python 3</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 实例]]></title>
    <url>%2Fposts%2F50958%2F</url>
    <content type="text"><![CDATA[摄氏度转华氏度 123a = float(input("输入摄氏度："))b = a * 1.8 + 32print("摄氏度：&#123;&#125;℃ = 华氏度：&#123;&#125;℉".format(a, b)) 求园的面积 123r = float(input("输入园半径："))area = math.pi*r**2print("半径为&#123;&#125;的园面积为&#123;&#125;".format(r, area)) 开平方根 123num1 = float(input("输入一个数："))result = num1 ** 0.5print("&#123;&#125;开平方=&#123;&#125;".format(num1, result)) 求三角形面积 123456a = float(input("输入边长："))b = float(input("输入边长："))c = float(input("输入边长："))p = (a + b + c) / 2s = (p * (p - a) * (p - b) * (p - c)) ** 0.5print("边长为&#123;&#125;，&#123;&#125;，&#123;&#125; 的三角形面积为&#123;&#125;".format(a, b, c, s)) 判断输入字符串是否为数字 123456789101112131415def is_number(s): """判断输入字符串是否为数字""" try: float(s) return True except ValueError: pass try: import unicodedata for i in s: unicodedata.numeric(i) return True except (ValueError, TypeError): pass return False 判断是否是奇数 123456789101112def is_odd(n): """判断是否是奇数""" try: if float(n) % 2 == 1: print("奇数") return True else: print("偶数") except ValueError: print("参数错误") pass return False 判断是否为闰年 1234567891011def is_leap_year(year): """判断是否为闰年""" try: year = float(year) if year % 4 == 0 and year % 100 != 0 or year % 400 == 0: return True else: return False except ValueError: print("参数错误") pass 获取最大值 123def max_num(s): """获取最大值""" return max(s) 判断是否为质数 1234567891011def is_prime(num): """判断是否为质数""" try: num = int(num) for i in range(2, num): if num % i == 0: return False else: return True except ValueError: pass 输出指定范围内的质数 123456789101112131415def scope_prime(min, max): """输出指定范围内的质数""" try: min = int(min) max = int(max) prime = set() for i in range(min, max + 1): for j in range(2, i): if i % j == 0: break else: prime.add(i) return prime except (TypeError, ValueError): pass 阶乘 12345678910111213141516def factorial(num): """阶乘""" try: num = int(num) if num == 1: return 1 else: # 递归实现 return num * factorial(num - 1) # 非递归实现 # factorial = 1 # for i in range(1, num + 1): # factorial *= i # return factorial except(TypeError, ValueError): pass 乘法表 123456def get_multiplication(): """乘法表""" for i in range(1, 10): for j in range(1, i + 1): print("&#123;&#125;x&#123;&#125;=&#123;&#125;\t".format(i, j, i * j), end="") print() 斐波那契数列 12345678def get_fibonacci(n): """斐波那契数列(0,1,1,2,3,5..)""" fib_list = [0, 1] if n == 1: return [0, ] for i in range(2, n): fib_list.append(fib_list[i - 2] + fib_list[i - 1]) return fib_list 阿姆斯特朗数 123456789101112131415161718def get_armstrong(n): """阿姆斯特朗数""" a = [] b = [] for i in range(1, n + 1): temp = i count = 0 sum_num = 0 a.clear() while int(temp % 10) != 0 or int(temp / 10) != 0: a.append(int(temp % 10)) temp /= 10 count += 1 for j in iter(a): sum_num += j ** count if sum_num == i: b.append(i) return b 进制转 1234567891011def change_type(num): # 十进制转二进制 print("二进制为：&#123;&#125;".format(bin(num))) # 十进制转八进制 print("八进制为：&#123;&#125;".format(oct(num))) # 十进制转十六进制 print("十六进制为：&#123;&#125;".format(hex(num))) # 字符转ASCII码 print("ASCII码为：&#123;&#125;".format(ord(num))) # ASCII码转字符 print("字符为：&#123;&#125;".format(chr(num))) 最大公约数 12345678def get_max_divisor(x, y): """最大公约数""" if x &gt; y: x, y = y, x for i in range(1, x + 1): if x % i == 0 and y % i == 0: divisor = i return divisor 最小公倍数 12345678def get_min_multiple(x, y): """最小公倍数""" if x &lt; y: x, y = y, x multiple = y while multiple % x != 0 or multiple % y != 0: multiple += 1 return multiple 日历 123def my_calendar(year, month): """日历""" print(calendar.month(year, month)) 递归 斐波那契数列 123456def recur_fibo(n): """递归 斐波那契数列""" if n &lt;= 1: return n else: return recur_fibo(n - 1) + recur_fibo(n - 2) 文件输入输出 1234567def file_test(file_name, my_input): """文件输入输出""" with open(file_name, 'w+') as file: file.write(my_input) with open(file_name, 'r') as file: output = file.read() return output 字符串大小写转换 1234567def up2down_or_down2up(my_str): """字符串大小写转换""" my_str = str(my_str) print(my_str.upper()) print(my_str.lower()) print(my_str.title()) print(my_str.capitalize()) 获得昨天日期 123456def get_yesterday(): """获得昨天日期""" today = datetime.date.today() one_day = datetime.timedelta(days=1) yesterday = today - one_day return yesterday 约瑟夫环 1234567891011121314151617181920212223242526def joseph(): """约瑟夫环""" people = [] for i in range(0, 30): # 1,在船上，0,落水 people.append(1) # 报数 check = 0 # 落水人数 num = 0 # 指针 index = -1 while num &lt; 15: # 报数 check = check + 1 index = index + 1 index = index % 30 while people[index] == 0: index = index + 1 index = index % 30 if check == 9: people[index] = 0 print('&#123;&#125;号下船'.format(index + 1)) num = num + 1 check = 0 # print(str(people)) 123456789def joseph2(): """约瑟夫环""" people = list(range(30)) while len(people) &gt; 15: i = 1 while i &lt; 9: people.append(people.pop(0)) i += 1 print('&#123;:2d&#125;号下船了'.format(people.pop(0))) 秒表功能实现 12345678910111213141516def stopwatch(): """秒表功能实现""" print('按下回车开始计时，按下Ctrl+c停止计时') while True: try: input() starttime = time.time() print('开始') while True: print('计时：', round(time.time() - starttime, 0), '秒', end='\r') time.sleep(1) except KeyboardInterrupt: print('结束') endtime = time.time() print('总共的时间为：', round(endtime - starttime, 2), 'secs') break 计算n个自然数的立方和 123def cube_sum(n): """计算n个自然数的立方和""" return sum([num ** 3 for num in range(1, n + 1)]) 数组翻转指定个数元素 123456def list_flip(arr, n): """数组翻转指定个数元素""" arr = list(arr) for i in range(n): arr.append(arr.pop(0)) return arr 数组首尾对调 1234def list_exchange(arr): """数组首尾对调""" arr[0], arr[len(arr) - 1] = arr[len(arr) - 1], arr[0] return arr 指定位置对调 12345678910def list_exchange(arr, x, y): # 数组指定位置对调 arr[x], arr[y] = arr[y], arr[x] # 判断数组中是否有3 if 3 in arr: print("数组中包含3") # 计算数组中元素出现的次数 print('数组中元素2出现了：&#123;&#125;次'.format(arr.count(2))) # 翻转数组 return [ele for ele in reversed(arr)] 正则表达式获取字符串中的url 12345def get_url(str): """正则表达式获取字符串中的url""" exp = r'https?://(?:[-\w.]|(?:%[\da-fA-F]&#123;2&#125;))+' url = re.findall(exp, str) return url 按key/value排序 1234567891011121314def sort_dic(): """按key/value排序""" key_value = &#123;2: 56, 1: 2, 5: 12, 4: 24, 6: 18, 3: 323&#125; key_value2 = &#123;7: 23, 8: 54&#125; print("按key排序") print(sorted(key_value.items())) # for i in sorted(key_value): # print((i, key_value[i]), end=' ') print("\n按value排序") print(sorted(key_value.items(), key=lambda kv: (kv[1], kv[0]))) print("字典值之和为：&#123;&#125;".format(sum(key_value.values()))) # 将字典2加入字典1 key_value.update(key_value2) print("两字典合并,key_value:&#123;&#125;, key_value2:&#123;&#125;".format(key_value, key_value2)) 时间转换 1234567891011a1 = "2019-7-20 23:40:00"# 先转换为时间数组timeArray = time.strptime(a1, "%Y-%m-%d %H:%M:%S")# 转换为时间戳timeStamp = int(time.mktime(timeArray))print(timeStamp)# 格式转换 - 转为 /otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)print(otherStyleTime)print("now:&#123;&#125;".format(datetime.datetime.now())) 二分查找 123456789101112131415161718192021def binary_search(arr, x): """二分查找,在有序数组arr中查找x所在的索引，找不到时返回-1""" left, right = 0, len(arr) - 1 while True: if right - left == 1: if arr[right] == x: return right elif arr[left] == x: return left else: return -1 else: mid = int((right + left) / 2) if x == arr[mid]: return mid elif x &gt; arr[mid]: left = mid continue elif x &lt; arr[mid]: right = mid continue 线性查找 123456def linear_search(arr, c): """线性查找""" for i in range(len(arr)): if arr[i] == c: return i return -1 打印杨辉三角 12345678910111213141516171819202122def pascal_triangles(n): triangles = &#123;&#125; n += 1 """杨辉三角""" for i in range(1, n): for j in range(1, i + 1): ij = str(i) + str(j) if j == 1: triangles[ij] = 1 print(" " * (n - i - 1), end='') print(1, end='') elif j == i: triangles[ij] = 1 print(1, end='') else: ul = str(i - 1) + str(j - 1) ur = str(i - 1) + str(j) triangles[ij] = triangles[ul] + triangles[ur] print(triangles[ij], end='') print(" ", end='') print() return triangles 白鸡百钱 123456789def chicken_question(): """百鸡百钱""" """ 鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ """ for x in range(0, 101): for y in range(0, 101): if 5 * x + 3 * y + (100 - x - y) / 3 == 100: print("鸡翁：&#123;&#125;、鸡母：&#123;&#125;、鸡雏：&#123;&#125;".format(x, y, 100 - x - y)) 完全数 123456789101112def perfect_number(n): """完全数""" temp = [] perfect = [] for i in range(1, n): for j in range(1, i): if i % j == 0 and i != j: temp.append(j) if sum(temp) == i: perfect.append(i) temp.clear() return perfect 小游戏Craps赌博游戏玩家摇两颗色子 如果第一次摇出7点或11点 玩家胜如果摇出2点 3点 12点 庄家胜 其他情况游戏继续玩家再次要色子 如果摇出7点 庄家胜如果摇出第一次摇的点数 玩家胜否则游戏继续 玩家继续摇色子玩家进入游戏时有1000元的赌注 全部输光游戏结束 123456789101112131415161718192021222324252627282930import randommoney = 1000while money &gt; 0: bet = int(input("请下注：")) while bet &gt; money or bet &lt;= 0: bet = int(input("请重新下注：")) money -= bet first_num = random.randint(2, 12) print("第一次：&#123;&#125;".format(first_num)) if first_num in [7, 11]: money += bet * 2 print("1.玩家胜出,获得：&#123;&#125;，剩余金币：【&#123;&#125;】".format(bet * 2, money)) continue elif first_num in [2, 3, 12]: print("2.庄家胜出，重新开始，剩余金币：【&#123;&#125;】".format(money)) continue else: while True: next_num = random.randint(2, 12) print("这一次：&#123;&#125;".format(next_num)) if next_num == 7: print("3.庄家胜出，重新开始，剩余金币：【&#123;&#125;】".format(money)) break elif next_num == first_num: money += bet * 2 print("4.玩家胜出,获得：&#123;&#125;，剩余金币：【&#123;&#125;】".format(bet * 2, money)) break # input()print("金币为零，游戏结束") 21点基于Python-100-Days的扑克游戏编写 游戏规则（简化版）： ​ 开局时，庄家给每个玩家（又称闲家）牌面向上发两张牌（明牌），再给庄家自己发两张牌，一张明牌，一张暗牌（牌面朝下）。​ 当所有的初始牌分发完毕后，如果玩家拿到的是A和T（无论顺序），就拥有黑杰克（Black Jack）；若庄家的明牌为T，且暗牌为A，应直接翻开并拥有Black Jack；如果庄家没有Black Jack则保持暗牌，玩家继续游戏。若玩家为Black Jack且庄家为其他，玩家赢得1.5倍（或2倍，1赔2时）赌注；若庄家为Black Jack且玩家为其他，庄家赢得赌注；若庄家和玩家均为Black Jack，平局，玩家拿回自己的赌注。​ 接下来是正常的拿牌流程：首名非黑杰克玩家选择拿牌（Hit）、停牌（Stand）、加倍（Double）或投降（Surrender，庄家赢得一半赌注）；若选择拿牌，则后续只能选择拿牌或停牌。在发牌的过程中，如果玩家的牌点数的和超过21，玩家就输了——叫爆掉（Bust），庄家赢得赌注（无论庄家之后的点数是多少）。假如玩家没爆掉，又决定不再要牌了（停牌，或因加倍、投降而终止），则轮到下一名非黑杰克玩家选择。​ 当所有玩家停止拿牌后，庄家翻开暗牌，并持续拿牌直至点数不小于17（若有A，按最大而尽量不爆计算）。假如庄家爆掉了，那他就输了，玩家赢得1倍赌注；否则那么比点数大小，大为赢。点数相同为平局，玩家拿回自己的赌注。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386import randomclass Card(object): """一张牌""" def __init__(self, suite, face): self._suite = suite self._face = face @property def face(self): return self._face @property def suite(self): return self._suite def __str__(self): if self._face == 1: face_str = 'A' elif self._face == 11: face_str = 'J' elif self._face == 12: face_str = 'Q' elif self._face == 13: face_str = 'K' else: face_str = str(self._face) return '%s%s' % (self._suite, face_str) def __repr__(self): return self.__str__()class Poker(object): """一副牌""" def __init__(self): self._cards = [Card(suite, face) for suite in '♠♥♣♦' for face in range(1, 14)] self._current = 0 @property def cards(self): return self._cards def shuffle(self): """洗牌(随机乱序)""" self._current = 0 random.shuffle(self._cards) @property def next(self): """发牌""" card = self._cards[self._current] self._current += 1 return card @property def has_next(self): """还有没有牌""" return self._current &lt; len(self._cards)class Player(object): """玩家""" def __init__(self, name): self._name = name self._cards_on_hand = [] @property def name(self): return self._name @property def cards_on_hand(self): return self._cards_on_hand def get(self, card): """摸牌""" self._cards_on_hand.append(card) def arrange(self, card_key): """玩家整理手上的牌""" self._cards_on_hand.sort(key=card_key)# 排序规则-先根据花色再根据点数排序class Black_Jack(Player): """21点""" def __init__(self, name): super().__init__(name) # 停牌 self._stand = False # 爆掉 self._bust = False @property def stand(self): return self._stand @stand.setter def stand(self, state): """停牌""" self._stand = state @property def bust(self): return self._bust @bust.setter def bust(self, state): """爆掉""" self._bust = state def is_stand(self): """是否停牌""" return self.black_jack_total() == 21 or self.face_total() &gt;= 17 def is_bust(self): """是否爆掉""" return self.face_total() &gt; 21 def open_hand(self, i): """明牌""" return self.cards_on_hand[i] def clean_hand(self): """清空手牌并清空状态""" self.cards_on_hand.clear() self.stand = False self.bust = False def face_total(self): """手牌总点数""" temp = [card.face for card in self.cards_on_hand] j_count = temp.count(11) q_count = temp.count(12) k_count = temp.count(13) total = sum(temp) - j_count - q_count * 2 - k_count * 3 return total def black_jack_total(self): """21点计数""" temp = [card.face for card in self.cards_on_hand] a_count = temp.count(1) j_count = temp.count(11) q_count = temp.count(12) k_count = temp.count(13) total = sum(temp) - j_count - q_count * 2 - k_count * 3 for i in range(a_count): if total &lt; 21: total += 10 if total &gt; 21: total -= 10 return totalclass Black_Jack_Player(Black_Jack): """21点玩家""" def __init__(self, name): super().__init__(name) # 玩家初始赌注 self._money = 1000 # 下注额 self._bet = 0 @property def money(self): return self._money @money.setter def money(self, money): """下注""" self._money = money @property def bet(self): return self._bet @bet.setter def bet(self, bet): """下注""" self._bet = bet def double(self): """加倍""" self._bet *= 2 def surrender(self): """投降""" self._bet /= 2 def __str__(self): return "【%s】筹码:%d，点数:%d，牌面:%s" % ( self._name, self._money, self.black_jack_total(), self.cards_on_hand)class Banker(Black_Jack): """庄家""" def __init__(self, name): super().__init__(name) # 是否是黑杰克 def is_black_jack(self): return self.cards_on_hand[0].face in [10, 11, 12, 13] and self.cards_on_hand[1].face == 1 def __str__(self): return "【%s】点数:%d，牌面:%s" % (self._name, self.black_jack_total(), self.cards_on_hand)def get_key(card): return card.suite, card.facedef main(): p = Poker() # print(p.cards) banker = Banker('庄家') # 电脑玩家 com_players = [Black_Jack_Player('东邪'), Black_Jack_Player('西毒'), Black_Jack_Player('南帝'), Black_Jack_Player('北丐')] player = Black_Jack_Player('玩家') while True: # 洗牌 p.shuffle() # 下注 for com_player in com_players: com_player.bet = random.randint(1, com_player.money) print("【&#123;&#125;】下注：&#123;&#125;".format(com_player.name, com_player.bet)) print('玩家当前筹码：&#123;&#125;'.format(player.money)) ok = False while not ok: try: player.bet = int(input("玩家请下注：")) if player.bet &gt; player.money: raise ValueError ok = True except ValueError: # 下注异常 print('输入有误') ok = False for i in range(2): # 庄家拿牌 banker.get(p.next) # 玩家拿牌 player.get(p.next) print('玩家拿牌：&#123;&#125;'.format(player.cards_on_hand[i])) # 电脑拿牌 for com_player in com_players: com_player.get(p.next) # 本轮是否结束标志 END = False # 庄家明牌 print("庄家明牌为：&#123;&#125;".format(banker.open_hand(0))) if banker.is_black_jack(): print("\n庄家有Black Jack：&#123;&#125;".format(banker.cards_on_hand)) # 庄家停牌 banker.stand = True # 直接结算筹码，结束本轮 END = True # 玩家轮流拿牌/停牌 while not END: for com_player in com_players: # 如果电脑玩家没停牌和爆掉则拿牌 # print('抽牌前：&#123;&#125;, stand:&#123;&#125;, bust:&#123;&#125;'.format(com_player.name, com_player.stand, com_player.bust)) if not com_player.stand and not com_player.bust: if com_player.is_stand(): com_player.stand = True print("【&#123;&#125;】:\"停牌！\"".format(com_player.name)) else: # 局势不错选择翻倍 if com_player.face_total in [10, 11, 12] and com_player.money &gt;= com_player.bet * 2: com_player.double() print("【&#123;&#125;】:\"运气不错，加倍！\"".format(com_player.name)) print("【&#123;&#125;】拿牌".format(com_player.name)) com_player.get(p.next) if com_player.is_bust(): com_player.bust = True print("【&#123;&#125;】爆掉！！".format(com_player.name)) # elif com_player.is_stand(): # com_player.stand = True # print("【&#123;&#125;】:\"停牌！\"".format(com_player.name)) # print('抽牌后：&#123;&#125;, stand:&#123;&#125;, bust:&#123;&#125;'.format(com_player.name, com_player.stand, com_player.bust)) if not player.bust and not player.stand: while True: print("当前手牌:&#123;&#125;，庄家明牌为：&#123;&#125;".format(player.cards_on_hand, banker.cards_on_hand[0])) print("请选择:1.拿牌，2.停牌，3.加倍") choose = int(input("选择:")) if choose == 1 or choose == 3: if choose == 3 and player.money &gt;= player.bet * 2: player.double() elif choose == 3: print('筹码不足，无法加倍！') player.get(p.next) if player.is_bust(): player.bust = True print('庄家发牌，当前手牌：&#123;&#125;'.format(player.cards_on_hand)) break elif choose == 2: player.stand = True break # 投降 # elif choose == 4: # player.surrender() # player.stand = True # break else: print("选择错误，请重新选择") temp = 0 for com_player in com_players: if com_player.stand or com_player.bust: temp += 1 if temp == len(com_players) and (player.bust or player.stand): END = True # 庄家抽牌 while not banker.bust and not banker.stand: banker.get(p.next) if banker.is_bust(): banker.bust = True elif banker.is_stand(): banker.stand = True # 结算筹码 if banker.bust: for com_player in com_players: if not com_player.bust: com_player.money += com_player.bet else: com_player.money -= com_player.bet if not player.bust: player.money += player.bet else: player.money -= player.bet else: for com_player in com_players: if com_player.black_jack_total() &gt; banker.black_jack_total() and not com_player.bust: # 玩家为21点时赢得1.5倍赌注 if com_player.black_jack_total() == 21: com_player.bet *= 1.5 com_player.money += com_player.bet elif com_player.black_jack_total() == banker.black_jack_total() and not com_player.bust: pass else: com_player.money -= com_player.bet if player.black_jack_total() &gt; banker.black_jack_total() and not player.bust: # 玩家为21点时赢得1.5倍赌注 if player.black_jack_total() == 21: player.bet *= 1.5 player.money += player.bet elif player.black_jack_total() == banker.black_jack_total() and not player.bust: pass else: player.money -= player.bet # 结束一轮 print("=" * 45) print(banker) banker.clean_hand() for com_player in com_players: # 清空手牌 print(com_player, end='') com_player.clean_hand() # 筹码为零则离席 if com_player.money == 0: com_players.remove(com_player) print("\n【&#123;&#125;】倾家荡产,被保安拖走...".format(com_player.name)) print() print(player) player.clean_hand() print("=" * 45) input("本轮结束，请按回车继续") if player.money &lt;= 0: break print("筹码已用完，游戏结束！！")if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python 3</category>
      </categories>
      <tags>
        <tag>实例</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2Fposts%2F27055%2F</url>
    <content type="text"><![CDATA[​ 在笔试中经常会遇到很多需要手写代码的题，如果能完整的写出来最好，但如果不习惯手写或时间不够，可已选择写伪码，主要描述清楚关键的实现步骤。 笔试 写出Collection接口的实现 Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap 运行时获取class的磁盘路径 1&lt;YOUR CLASS&gt;.class.getProtectionDomain().getCodeSource().getSource().getLocation() Java多态的表现形式，代码如何实现 重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现；不同的对象调用同一个方法的到不同的结果。 继承父类 重写父类方法 向上转型 在工作中遇到或使用过的设计模式，手写实现一个设计模式（除了单例模式） Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），Observer（观察者模式）， State（状态模式）， Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。具体实现代码 手写代码，实现多线程对一整型对象递增，且数值不重复 123456789101112131415161718192021222324public class Test &#123; private static int num = 1; public static void main(String[] args) &#123; Test test = new Test(); Increasing inc = test.new Increasing(); for (int i=0;i&lt;=10;i++)&#123; Thread thread=new Thread(inc); thread.start(); &#125; &#125; private synchronized void add()&#123; num+=1; System.out.println(num); &#125; class Increasing implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;20;i++)&#123; add(); &#125; &#125; &#125;&#125; 快速获得数组int[] a = {1,2, 3, 5, 6, 12, 4, 7, 14, 9, 8}中第二大的数，写出关键代码 下面代码的时间复杂度为O(n)，不一定是最快的，但只需遍历一次 12345678910111213public static int getSecondMax(int[] a) &#123; int max = a[0]; int second = a[a.length - 1]; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; second = max; max = a[i]; &#125; else if (a[i] &gt; second &amp;&amp; a[i] &lt; max) &#123; second = a[i]; &#125; &#125; return second;&#125; 进程和线程的区别和联系？ 进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程线程 - 操作系统分配CPU的基本单位 面试 在之前项目中遇到什么问题，怎么解决。 mysql分页语句。 线程同步有哪几种方式。 eclipse的中查找类被调用的快捷键是什么。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3与Java的简单对比之面向对象]]></title>
    <url>%2Fposts%2F44973%2F</url>
    <content type="text"><![CDATA[类(class)是构造对象的模板或蓝图。由类构造(construct)对象的过程称为创建类的实例(instance)。 Java核心技术 类提供了一种组合数据和功能的方法。创建一个新类意味着创建一个新类型的对象，从而允许创建一个该类型的新实例。 Python3.7.4文档 在对于类的定义上，Python3与Java定义一致。 类​ 下面分别用Java和Python3编写一个People类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * People */public class People &#123; //实例域（成员变量） private String name; private int age; private String gender; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; //无参构造器 public People() &#123; System.out.println("【JPeople】无参构造器"); &#125; //带参构造器 public People(String name, int age, String gender) &#123; System.out.println("【JPeople】带参构造器"); this.name = name; this.age = age; this.gender = gender; &#125; //静态方法 public static void f() &#123; System.out.println("【JPeople】静态方法"); &#125; //实例方法 public void sayHello() &#123; System.out.println("【JPeople】"+this.name + " say：\"Hello\""); pf(); &#125; //私有方法 private void pf()&#123; System.out.println("【JPeople】私有方法"); &#125;&#125;public class PeopleTest &#123; public static void main(String[] args) &#123; People tom = new People("tom", 18, "male"); tom.sayHello(); People.f(); &#125;&#125; ​ Java执行结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class People: """People""" # 私有属性 __gift = 100 # 类属性 name = '' age = 0 # 限定对象只能绑定_gender属性 # __slots__=('_gender') # 实例化方法 def __init__(self, name, age, gender): print("【PPeople】构造方法") self.name = name self.age = age self._gender = gender # getter方法 @property def gender(self): return self._gender # setter方法 @gender.setter def gender(self,gender): self._gender=gender # 静态方法 @staticmethod def sf(): print("【PPeople】静态方法") # 类方法 @classmethod def cf(cls): print("【PPeople】类方法") # 实例方法 def say_hello(self): print("【PPeople】&#123;&#125; say：\"Hello!\",gift=&#123;&#125;".format(self.name, self.__gift)) self.__pf() # 私有方法 def __pf(self): print("【PPeople】私有方法")People.age += 1print(People.age)People.sf()tom = People('Tom', 18, 'male')tom.gender="female"print(tom.gender)tom.say_hello() ​ Python执行结果 小结 Java Python 私有属性 （成员变量）使用private关键字修饰 属性名双下划线开头__；不建议将属性设置为私有，建议以_(单下划线)开头，暗示属性为受保护的，不建议外部直接访问，建议使用getter、setter进行操作 类属性 使用static修饰的变量 类和对象都可以访问 构造方法 有参、无参构造器；方法名与类名相同 (实例化方法)方法名固定__init__ 实例方法 对象访问 (普通方法)对象访问，默认有参self 私有方法 使用private关键字修饰 方法名双下划线开头__ 静态方法 使用static关键字修饰 使用@staticmethod装饰器,可以无参 类方法 同静态方法 使用@classmethod装饰器,类和对象访问,默认参数cls 继承​ 在Java中类只能单继承继承，因为Java的设计者认为，多继承会让语言本身变得非常复杂（如同C++），效率也会降低（如同Eiffrl），而为了让程序设计更加灵活，Java中就有了接口（interface），接口之间可以多继承。而Python的类可以多继承，也就没必要有接口；下面分别使用Java和Python 3实现Student子类 12345678910111213141516171819202122232425262728293031323334public class Student extends People&#123; //学号 private String studentNumber; public String getStudentNumber() &#123; return studentNumber; &#125; public void setStudentNumber(String studentNumber) &#123; this.studentNumber = studentNumber; &#125; //子类无参构造器 public Student() &#123; &#125; //带参构造器 public Student(String name, int age, String gender, String studentNumber) &#123; //调用父类带参构造器 super(name, age, gender); System.out.println("【JStudent】带参构造器"); this.studentNumber = studentNumber; &#125; //重写父类方法 public void sayHello()&#123; System.out.println("【JStudent】"+this.getName() + " say：\"Hello\""); &#125; public static void main(String[] args) &#123; Student student_1 = new Student("Jerry", 17, "male", "0021"); student_1.sayHello(); &#125;&#125; ​ Java执行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243# 单继承class Student(People): # 子类构造方法 def __init__(self, name, age, gender, student_number): print("【PStudent】构造方法--开始") # 调用超类构造方法 super(Student, self).__init__(name, age, gender) self.student_number = student_number print("【PStudent】构造方法--结束") # 重写父类方法 def say_hello(self): print("【PStudent】&#123;&#125; say：\"Hello!\"".format(self.name)) # Child类,为多继承做准备class Child: def __init__(self, name, mom, dad): print("【PChild】构造方法") self.name = name self.mom = mom self.dad = dad def cry(self): print('【PChild】'+self.name + ":\'wow wow\'")# 多重继承class Kid(Student, Child): def __init__(self, name, age, gender, student_number, mom, dad): print("【PKid】构造方法--开始") Student.__init__(self, name, age, gender, student_number) Child.__init__(self, name, mom, dad) print("【PKid】构造方法--结束") def info(self): print('【PKid】'+', '.join(['%s:%s' % item for item in self.__dict__.items()]))# 创建一个Student对象jerry = Student("Jerry", 17, 'male', '0021')print(jerry.name)jerry.say_hello()# 创建一个Kid对象kid = Kid("小明", 12, "男", "0023", "Tom", "Jerry")kid.info() ​ Python执行结果 小结​ Java与Python 3 在掉用构造方法时顺序是一致的，但是Java在构造方法内调用父类构造方法，语句super()必须放在方法体的第一句；而Python 3，对象是由 __new__()和__init__()协作构造完成，实例通过__new__方法被创建，使用__init__方法进行初始化；所以在调用父类方法之前，可以对参数进行定制修改。Python 3 的多继承，在搜索从父类继承的方法/属性时，可以简单认为是深度优先、从左至右；但为了保持单次调用，实际在调用时是动态的； 多态​ 实现多态的步骤：1.继承父类 2.重写父类方法 3.向上转型 1234567891011121314/**1.Teacher继承自People**/public class Teacher extends People &#123; public Teacher() &#123; &#125; public Teacher(String name, int age, String gender) &#123; super(name, age, gender); &#125; //2.重写sayHello方法 public void sayHello() &#123; System.out.println("【JTeacher】"+this.getName() + "：\" 同学们早上好！\""); &#125;&#125; 123456789public class Test &#123; public static void main(String[] args) &#123; //3.向上转型 People teacher= new Teacher("王阳明",45,"男"); teacher.sayHello(); People student =new Student("小明", 17, "男", "0021"); student.sayHello(); &#125;&#125; java运行结果： 1234567891011121314class Teacher(People): """继承自People""" def __init__(self, name, age, gender): print("【PTeacher】构造方法--开始") super(Teacher, self).__init__(name, age, gender) print("【PTeacher】构造方法--结束") def say_hello(self): print("【PTeacher】&#123;&#125; say：\"同学们好！\"".format(self.name)) people_1 = Student("小明", 12, "男", "0023")people_1.say_hello()people_2 = Teacher("王阳明", 45, "男")people_2.say_hello() Python运行结果： 小结 Python从语法层面并没有像Java那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod（class CLASSNAME(metaclass=ABCMeta):）包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python3</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7查杀nanoWath挖矿木马]]></title>
    <url>%2Fposts%2F34761%2F</url>
    <content type="text"><![CDATA[前几天在查看服务器时状态时发现cpu占用率达到了103% 这个VPS主要是拿来玩玩，平时上面并没有什么大的服务再运行，不可能会占满CPU的；用shell客户端连上VPS，执行ps aux，其中一个叫nanoWatch的进程cpu占用率达到了99.5% 直接杀掉这个进程kill -9 17305,再检查进程，没发现异常 过了没几分钟，cpu占用又满了，查看进程，这个进程又出现了； 找到/tmp/nanoWatch这个文件，删掉这个文件，再杀掉进程，过了几分钟，进进程再次出现。 我怀疑是定时启动的任务， crontab -l查看cron计划任务，显示出来了两个定时任务，每5分钟和7分钟执行一次下载文件，我手动把这个文件下下来，是一个脚本 删除定时任务crontab -r，删掉文件，杀掉进程，结束了。 过了两天，又出现CPU占用异常。 我之前一直是用root用户并使用20端口进行ssh连接，这是非常不安全的行为，很容易被端口扫描暴力破解密码登录服务器。简单的解决办法如下 [TOC] 修改ssh连接端口用 root 用户进入 /etc/ssh/ 1234cd /etc/ssh/#用 vi 打开 sshd_config 文件vim sshd_config#添加端口20022（22号是默认端口，注释掉也是默认开启的），并解开22端口注释 123456789#重启ssh systemctl restart sshd#查看防火墙规则firewall-cmd --permanent --list-port#向防火墙中添加端口firewall-cmd --zone=public --add-port=20022/tcp --permanentreaload #重新加载防火墙规则firewall-cmd --reload 12#查看20022端口是否添加成功firewall-cmd --zone=public --query-port=20022/tcp 断开ssh连接，换用20022端口连接修改/etc/ssh/sshd_config将22号端口注释掉 1234#重启sshsystemctl restart sshd#查看ssh监听的端口ss -tnlp|grep ssh 禁用root登入，使用普通用户登入12345#先创建一个普通用户test,同时给test用户设置密码adduser testpasswd test#接着禁用root登录(修改sshd_config文件)vi /etc/ssh/sshd_config 12#重启sshSystemctl restart sshd.service]]></content>
      <categories>
        <category>服务器安全</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker启动Redis]]></title>
    <url>%2Fposts%2F61166%2F</url>
    <content type="text"><![CDATA[12#docker中启动redis并设置密码docker run -d --name myredis -p 6379:6379 redis --requirepass "mypassword"]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装RabbitMq]]></title>
    <url>%2Fposts%2F62858%2F</url>
    <content type="text"><![CDATA[12#设置rabbit默认用户与密码docker run -d --hostname rabbit-host --name rabbitMq -e RABBITMQ_DEFAULT_USER=username -e RABBITMQ_DEFAULT_PASS=password -p 5672:5672 -p 15672:15672 rabbitmq:3.7.3-management 12#在docker中停止rabbitMqdocker stop rabbitMq]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>RabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装Mysql5.7]]></title>
    <url>%2Fposts%2F57388%2F</url>
    <content type="text"><![CDATA[在Docker中mysql5.7安装和设置与8.0基本一致 1234567891011121314151617# docker 中下载 mysqldocker pull mysql:5.7#启动并设置root密码docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=your_password -d mysql:5.7#进入容器docker exec -it mysql bash#登录mysqlmysql -u root -p#设置root用户密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_password';#添加远程登录用户CREATE USER 'your_username'@'%' IDENTIFIED WITH mysql_native_password BY 'your_password';GRANT ALL PRIVILEGES ON *.* TO 'your_password'@'%';]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IDEA中使用Dockerfile]]></title>
    <url>%2Fposts%2F55214%2F</url>
    <content type="text"><![CDATA[在IDEA中使用Dockerfile简单步骤 在项目根目录创建Dockerfile文件 在Dockerfile中写入 1234567891011#引用基础镜像FROM java:8-jre#将需要在Docker中运行的jar包复制到镜像中ADD target/*.jar applicationName.jar#暴露端口EXPOSE 8888#容器启动时执行的命令ENTRYPOINT ["java", "-jar", "applicationName.jar", "--server.port=8888"] 使用maven打包项目，运行Dockerfile文件 ps:启动前需要配置IDEA与Docker服务器的连接]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Dockerflie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud配置SSH连接统一配置中心]]></title>
    <url>%2Fposts%2F35191%2F</url>
    <content type="text"><![CDATA[当时在配置ssh连接的时候不知不觉就掉坑里去了，对一些知识点没完全理解； 先说说的掉坑，复制id_rsa文件内的文本出来，放进bootstrap.yml的privateKey中，如下图 启动报错 12Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under &apos;spring.cloud.config.server.git&apos; to org.springframework.cloud.config.server.environment.MultipleJGitEnvironmentProperties failed: Reason: Property &apos;spring.cloud.config.server.git.privateKey&apos; is not a valid private key 我们看看官网怎么配spring.cloud.config.server.git的 有没有发现不一样，没错，官网配置的privateKey里少了前3行属性为什么？？？因为官网的秘钥在生成时是没有设置秘钥密码的，而我们的秘钥是有密码的，它没办法解密秘钥；解决办法两种： ==我们在生成秘钥时也不设置秘钥密码== ==在yml中配置的git属性添加passphrase== 下面是全配置过程，主要分3步 生成公钥与私钥打开Git Bash/Terminal，输入ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 引号里面替换成你的邮箱地址或标志自己身份的信息 提示保存秘钥的文件位置，直接回车保持默认位置 设置秘钥密码（直接回车则不设置秘钥密码），生成公钥、秘钥 完成之后可以在/root/.ssh/目录下找到公钥（id_rsa.pub）秘钥（id_rsa） 将公钥添加到git上复制id_rsa.pub的内容出来 打开github，进入需要拉取文件的仓库，进入设置标签页 点击Add Deploy key 输入GitHub密码确认 刚添加的公钥是灰色的，还没有被使用 在bootstrap.yml中配置把id_rsa的全部内容复制出来，放到private-key属性 注意： uri要用ssh形式的地址 ignore-local-ssh-settings设置为true，忽略本地的ssh配置 passphrase内要配置上面设置的秘钥密码 启动项目后，可以在Github的仓库设置中看到公钥已经被使用，变成了绿色。 至此spring-cloud-config使用ssh连接git就配置完成。 修改秘钥密码打开Git Bash/Terminal，输入ls-al ~/.ssh 检查之前是否已经生成了SSH key 如果是这样的那就说明已经生成过秘钥，可以选择修改修改私钥密码（passphrase）输入 ssh-keygen -p 直接回车继续，输入旧密码，然后输入两次新密码]]></content>
      <categories>
        <category>Java</category>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
