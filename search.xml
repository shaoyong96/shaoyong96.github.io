<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 3 实现常见排序算法]]></title>
    <url>%2F2019%2F08%2F10%2Fcjz5mrm540004csdax1x88e0p%2F</url>
    <content type="text"><![CDATA[直接插入排序12345678def insertion_sort(arr): """直接插入排序""" for i in range(1, len(arr)): for j in range(0, i): if arr[i] &lt; arr[j]: arr.insert(j, arr.pop(i)) print("第&#123;&#125;轮排序后结果为：&#123;&#125;".format(i, arr)) return arr 快速排序123456789101112131415161718def quick_partition(arr, low, high): i = (low - 1) # 最小元素索引 pivot = arr[high] for j in range(low, high): # 当前元素小于或等于 pivot if arr[j] &lt;= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1def quick_sort(arr, low, high): """快速排序""" if low &lt; high: temp = quick_partition(arr, low, high) quick_sort(arr, low, temp - 1) quick_sort(arr, temp + 1, high) 选择排序1234567891011121314def select_sort(arr): """选择排序""" sort_list = [] min_index = 0 while len(arr) != 0: # 取出余下数列中最小的值的索引 for i in range(0, len(arr)): if arr[i] &lt; arr[min_index]: min_index = i # 将值取出放入新数组 sort_list.append(arr.pop(min_index)) # 归零索引 min_index = 0 return sort_list 冒泡排序1234567def bubble_sort(arr): """冒泡排序""" for t in range(len(arr) - 1): for i in range(len(arr) - 1 - t): if arr[i] &gt; arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr 归并排序1234567891011121314151617181920212223def merge_sort(arr): """归并排序""" # 计算中值 mid = len(arr) // 2 # 切割左右数组 left = arr[:mid] right = arr[mid:] merge = [] # 左边数组元素个数大于1时归并排序 if len(left) &gt; 1: left = merge_sort(left) # 右边数组元素个数大于1时归并排序 if len(right) &gt; 1: right = merge_sort(right) # 归并左右数组 while left and right: if right[0] &lt;= left[0]: merge.append(right.pop(0)) else: merge.append(left.pop(0)) merge.extend(left) merge.extend(right) return merge 堆排序123456789def heap_sort(arr): """堆排序""" result = [] while arr: # 初始化堆 arr = min_heap(arr) # 取出堆顶元素 result.append(arr.pop(0)) return result 建最小堆123456789101112131415161718192021def min_heap(arr): """建最小堆""" arr = list(arr) le = len(arr) mid = le // 2 for i in range(0, mid): temp = mid - i # 判断是否有右支 if 2 * temp == le: # 无右支，比较左支并交换 if arr[temp - 1] &gt; arr[temp * 2 - 1]: arr[temp - 1], arr[temp * 2 - 1] = arr[temp * 2 - 1], arr[temp - 1] else: # 比较左右支,并与父节点交换 if arr[temp * 2 - 1] &gt; arr[temp * 2]: min_index = temp * 2 else: min_index = temp * 2 - 1 if arr[temp - 1] &gt; arr[min_index]: arr[temp - 1], arr[min_index] = arr[min_index], arr[temp - 1] return arr 希尔排序1234567891011121314def shell_sort(arr): """希尔排序""" n = len(arr) gap = n // 2 while gap &gt; 0: for i in range(gap, n): temp = arr[i] j = i while j &gt;= gap and arr[j - gap] &gt; temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap = gap // 2 return arr]]></content>
      <categories>
        <category>Python 3</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 实例]]></title>
    <url>%2F2019%2F08%2F02%2Fcjz5jrzbk001kk4daosh61keq%2F</url>
    <content type="text"><![CDATA[摄氏度转华氏度 123a = float(input("输入摄氏度："))b = a * 1.8 + 32print("摄氏度：&#123;&#125;℃ = 华氏度：&#123;&#125;℉".format(a, b)) 求园的面积 123r = float(input("输入园半径："))area = math.pi*r**2print("半径为&#123;&#125;的园面积为&#123;&#125;".format(r, area)) 开平方根 123num1 = float(input("输入一个数："))result = num1 ** 0.5print("&#123;&#125;开平方=&#123;&#125;".format(num1, result)) 求三角形面积 123456a = float(input("输入边长："))b = float(input("输入边长："))c = float(input("输入边长："))p = (a + b + c) / 2s = (p * (p - a) * (p - b) * (p - c)) ** 0.5print("边长为&#123;&#125;，&#123;&#125;，&#123;&#125; 的三角形面积为&#123;&#125;".format(a, b, c, s)) 判断输入字符串是否为数字 123456789101112131415def is_number(s): """判断输入字符串是否为数字""" try: float(s) return True except ValueError: pass try: import unicodedata for i in s: unicodedata.numeric(i) return True except (ValueError, TypeError): pass return False 判断是否是奇数 123456789101112def is_odd(n): """判断是否是奇数""" try: if float(n) % 2 == 1: print("奇数") return True else: print("偶数") except ValueError: print("参数错误") pass return False 判断是否为闰年 1234567891011def is_leap_year(year): """判断是否为闰年""" try: year = float(year) if year % 4 == 0 and year % 100 != 0 or year % 400 == 0: return True else: return False except ValueError: print("参数错误") pass 获取最大值 123def max_num(s): """获取最大值""" return max(s) 判断是否为质数 1234567891011def is_prime(num): """判断是否为质数""" try: num = int(num) for i in range(2, num): if num % i == 0: return False else: return True except ValueError: pass 输出指定范围内的质数 123456789101112131415def scope_prime(min, max): """输出指定范围内的质数""" try: min = int(min) max = int(max) prime = set() for i in range(min, max + 1): for j in range(2, i): if i % j == 0: break else: prime.add(i) return prime except (TypeError, ValueError): pass 阶乘 12345678910111213141516def factorial(num): """阶乘""" try: num = int(num) if num == 1: return 1 else: # 递归实现 return num * factorial(num - 1) # 非递归实现 # factorial = 1 # for i in range(1, num + 1): # factorial *= i # return factorial except(TypeError, ValueError): pass 乘法表 123456def get_multiplication(): """乘法表""" for i in range(1, 10): for j in range(1, i + 1): print("&#123;&#125;x&#123;&#125;=&#123;&#125;\t".format(i, j, i * j), end="") print() 斐波那契数列 12345678def get_fibonacci(n): """斐波那契数列(0,1,1,2,3,5..)""" fib_list = [0, 1] if n == 1: return [0, ] for i in range(2, n): fib_list.append(fib_list[i - 2] + fib_list[i - 1]) return fib_list 阿姆斯特朗数 123456789101112131415161718def get_armstrong(n): """阿姆斯特朗数""" a = [] b = [] for i in range(1, n + 1): temp = i count = 0 sum_num = 0 a.clear() while int(temp % 10) != 0 or int(temp / 10) != 0: a.append(int(temp % 10)) temp /= 10 count += 1 for j in iter(a): sum_num += j ** count if sum_num == i: b.append(i) return b 进制转 1234567891011def change_type(num): # 十进制转二进制 print("二进制为：&#123;&#125;".format(bin(num))) # 十进制转八进制 print("八进制为：&#123;&#125;".format(oct(num))) # 十进制转十六进制 print("十六进制为：&#123;&#125;".format(hex(num))) # 字符转ASCII码 print("ASCII码为：&#123;&#125;".format(ord(num))) # ASCII码转字符 print("字符为：&#123;&#125;".format(chr(num))) 最大公约数 12345678def get_max_divisor(x, y): """最大公约数""" if x &gt; y: x, y = y, x for i in range(1, x + 1): if x % i == 0 and y % i == 0: divisor = i return divisor 最小公倍数 12345678def get_min_multiple(x, y): """最小公倍数""" if x &lt; y: x, y = y, x multiple = y while multiple % x != 0 or multiple % y != 0: multiple += 1 return multiple 日历 123def my_calendar(year, month): """日历""" print(calendar.month(year, month)) 递归 斐波那契数列 123456def recur_fibo(n): """递归 斐波那契数列""" if n &lt;= 1: return n else: return recur_fibo(n - 1) + recur_fibo(n - 2) 文件输入输出 1234567def file_test(file_name, my_input): """文件输入输出""" with open(file_name, 'w+') as file: file.write(my_input) with open(file_name, 'r') as file: output = file.read() return output 字符串大小写转换 1234567def up2down_or_down2up(my_str): """字符串大小写转换""" my_str = str(my_str) print(my_str.upper()) print(my_str.lower()) print(my_str.title()) print(my_str.capitalize()) 获得昨天日期 123456def get_yesterday(): """获得昨天日期""" today = datetime.date.today() one_day = datetime.timedelta(days=1) yesterday = today - one_day return yesterday 约瑟夫环 1234567891011121314151617181920212223242526def joseph(): """约瑟夫环""" people = [] for i in range(0, 30): # 1,在船上，0,落水 people.append(1) # 报数 check = 0 # 落水人数 num = 0 # 指针 index = -1 while num &lt; 15: # 报数 check = check + 1 index = index + 1 index = index % 30 while people[index] == 0: index = index + 1 index = index % 30 if check == 9: people[index] = 0 print('&#123;&#125;号下船'.format(index + 1)) num = num + 1 check = 0 # print(str(people)) 123456789def joseph2(): """约瑟夫环""" people = list(range(30)) while len(people) &gt; 15: i = 1 while i &lt; 9: people.append(people.pop(0)) i += 1 print('&#123;:2d&#125;号下船了'.format(people.pop(0))) 秒表功能实现 12345678910111213141516def stopwatch(): """秒表功能实现""" print('按下回车开始计时，按下Ctrl+c停止计时') while True: try: input() starttime = time.time() print('开始') while True: print('计时：', round(time.time() - starttime, 0), '秒', end='\r') time.sleep(1) except KeyboardInterrupt: print('结束') endtime = time.time() print('总共的时间为：', round(endtime - starttime, 2), 'secs') break 计算n个自然数的立方和 123def cube_sum(n): """计算n个自然数的立方和""" return sum([num ** 3 for num in range(1, n + 1)]) 数组翻转指定个数元素 123456def list_flip(arr, n): """数组翻转指定个数元素""" arr = list(arr) for i in range(n): arr.append(arr.pop(0)) return arr 数组首尾对调 1234def list_exchange(arr): """数组首尾对调""" arr[0], arr[len(arr) - 1] = arr[len(arr) - 1], arr[0] return arr 指定位置对调 12345678910def list_exchange(arr, x, y): # 数组指定位置对调 arr[x], arr[y] = arr[y], arr[x] # 判断数组中是否有3 if 3 in arr: print("数组中包含3") # 计算数组中元素出现的次数 print('数组中元素2出现了：&#123;&#125;次'.format(arr.count(2))) # 翻转数组 return [ele for ele in reversed(arr)] 正则表达式获取字符串中的url 12345def get_url(str): """正则表达式获取字符串中的url""" exp = r'https?://(?:[-\w.]|(?:%[\da-fA-F]&#123;2&#125;))+' url = re.findall(exp, str) return url 按key/value排序 1234567891011121314def sort_dic(): """按key/value排序""" key_value = &#123;2: 56, 1: 2, 5: 12, 4: 24, 6: 18, 3: 323&#125; key_value2 = &#123;7: 23, 8: 54&#125; print("按key排序") print(sorted(key_value.items())) # for i in sorted(key_value): # print((i, key_value[i]), end=' ') print("\n按value排序") print(sorted(key_value.items(), key=lambda kv: (kv[1], kv[0]))) print("字典值之和为：&#123;&#125;".format(sum(key_value.values()))) # 将字典2加入字典1 key_value.update(key_value2) print("两字典合并,key_value:&#123;&#125;, key_value2:&#123;&#125;".format(key_value, key_value2)) 时间转换 1234567891011a1 = "2019-7-20 23:40:00"# 先转换为时间数组timeArray = time.strptime(a1, "%Y-%m-%d %H:%M:%S")# 转换为时间戳timeStamp = int(time.mktime(timeArray))print(timeStamp)# 格式转换 - 转为 /otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)print(otherStyleTime)print("now:&#123;&#125;".format(datetime.datetime.now())) 二分查找 123456789101112131415161718192021def binary_search(arr, x): """二分查找,在有序数组arr中查找x所在的索引，找不到时返回-1""" left, right = 0, len(arr) - 1 while True: if right - left == 1: if arr[right] == x: return right elif arr[left] == x: return left else: return -1 else: mid = int((right + left) / 2) if x == arr[mid]: return mid elif x &gt; arr[mid]: left = mid continue elif x &lt; arr[mid]: right = mid continue 线性查找 123456def linear_search(arr, c): """线性查找""" for i in range(len(arr)): if arr[i] == c: return i return -1 打印杨辉三角 12345678910111213141516171819202122def pascal_triangles(n): triangles = &#123;&#125; n += 1 """杨辉三角""" for i in range(1, n): for j in range(1, i + 1): ij = str(i) + str(j) if j == 1: triangles[ij] = 1 print(" " * (n - i - 1), end='') print(1, end='') elif j == i: triangles[ij] = 1 print(1, end='') else: ul = str(i - 1) + str(j - 1) ur = str(i - 1) + str(j) triangles[ij] = triangles[ul] + triangles[ur] print(triangles[ij], end='') print(" ", end='') print() return triangles 白鸡百钱 123456789def chicken_question(): """百鸡百钱""" """ 鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ """ for x in range(0, 101): for y in range(0, 101): if 5 * x + 3 * y + (100 - x - y) / 3 == 100: print("鸡翁：&#123;&#125;、鸡母：&#123;&#125;、鸡雏：&#123;&#125;".format(x, y, 100 - x - y)) 完全数 123456789101112def perfect_number(n): """完全数""" temp = [] perfect = [] for i in range(1, n): for j in range(1, i): if i % j == 0 and i != j: temp.append(j) if sum(temp) == i: perfect.append(i) temp.clear() return perfect 小游戏Craps赌博游戏玩家摇两颗色子 如果第一次摇出7点或11点 玩家胜如果摇出2点 3点 12点 庄家胜 其他情况游戏继续玩家再次要色子 如果摇出7点 庄家胜如果摇出第一次摇的点数 玩家胜否则游戏继续 玩家继续摇色子玩家进入游戏时有1000元的赌注 全部输光游戏结束 123456789101112131415161718192021222324252627282930import randommoney = 1000while money &gt; 0: bet = int(input("请下注：")) while bet &gt; money or bet &lt;= 0: bet = int(input("请重新下注：")) money -= bet first_num = random.randint(2, 12) print("第一次：&#123;&#125;".format(first_num)) if first_num in [7, 11]: money += bet * 2 print("1.玩家胜出,获得：&#123;&#125;，剩余金币：【&#123;&#125;】".format(bet * 2, money)) continue elif first_num in [2, 3, 12]: print("2.庄家胜出，重新开始，剩余金币：【&#123;&#125;】".format(money)) continue else: while True: next_num = random.randint(2, 12) print("这一次：&#123;&#125;".format(next_num)) if next_num == 7: print("3.庄家胜出，重新开始，剩余金币：【&#123;&#125;】".format(money)) break elif next_num == first_num: money += bet * 2 print("4.玩家胜出,获得：&#123;&#125;，剩余金币：【&#123;&#125;】".format(bet * 2, money)) break # input()print("金币为零，游戏结束") 21点基于Python-100-Days的扑克游戏编写 游戏规则（简化版）： ​ 开局时，庄家给每个玩家（又称闲家）牌面向上发两张牌（明牌），再给庄家自己发两张牌，一张明牌，一张暗牌（牌面朝下）。​ 当所有的初始牌分发完毕后，如果玩家拿到的是A和T（无论顺序），就拥有黑杰克（Black Jack）；若庄家的明牌为T，且暗牌为A，应直接翻开并拥有Black Jack；如果庄家没有Black Jack则保持暗牌，玩家继续游戏。若玩家为Black Jack且庄家为其他，玩家赢得1.5倍（或2倍，1赔2时）赌注；若庄家为Black Jack且玩家为其他，庄家赢得赌注；若庄家和玩家均为Black Jack，平局，玩家拿回自己的赌注。​ 接下来是正常的拿牌流程：首名非黑杰克玩家选择拿牌（Hit）、停牌（Stand）、加倍（Double）或投降（Surrender，庄家赢得一半赌注）；若选择拿牌，则后续只能选择拿牌或停牌。在发牌的过程中，如果玩家的牌点数的和超过21，玩家就输了——叫爆掉（Bust），庄家赢得赌注（无论庄家之后的点数是多少）。假如玩家没爆掉，又决定不再要牌了（停牌，或因加倍、投降而终止），则轮到下一名非黑杰克玩家选择。​ 当所有玩家停止拿牌后，庄家翻开暗牌，并持续拿牌直至点数不小于17（若有A，按最大而尽量不爆计算）。假如庄家爆掉了，那他就输了，玩家赢得1倍赌注；否则那么比点数大小，大为赢。点数相同为平局，玩家拿回自己的赌注。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386import randomclass Card(object): """一张牌""" def __init__(self, suite, face): self._suite = suite self._face = face @property def face(self): return self._face @property def suite(self): return self._suite def __str__(self): if self._face == 1: face_str = 'A' elif self._face == 11: face_str = 'J' elif self._face == 12: face_str = 'Q' elif self._face == 13: face_str = 'K' else: face_str = str(self._face) return '%s%s' % (self._suite, face_str) def __repr__(self): return self.__str__()class Poker(object): """一副牌""" def __init__(self): self._cards = [Card(suite, face) for suite in '♠♥♣♦' for face in range(1, 14)] self._current = 0 @property def cards(self): return self._cards def shuffle(self): """洗牌(随机乱序)""" self._current = 0 random.shuffle(self._cards) @property def next(self): """发牌""" card = self._cards[self._current] self._current += 1 return card @property def has_next(self): """还有没有牌""" return self._current &lt; len(self._cards)class Player(object): """玩家""" def __init__(self, name): self._name = name self._cards_on_hand = [] @property def name(self): return self._name @property def cards_on_hand(self): return self._cards_on_hand def get(self, card): """摸牌""" self._cards_on_hand.append(card) def arrange(self, card_key): """玩家整理手上的牌""" self._cards_on_hand.sort(key=card_key)# 排序规则-先根据花色再根据点数排序class Black_Jack(Player): """21点""" def __init__(self, name): super().__init__(name) # 停牌 self._stand = False # 爆掉 self._bust = False @property def stand(self): return self._stand @stand.setter def stand(self, state): """停牌""" self._stand = state @property def bust(self): return self._bust @bust.setter def bust(self, state): """爆掉""" self._bust = state def is_stand(self): """是否停牌""" return self.black_jack_total() == 21 or self.face_total() &gt;= 17 def is_bust(self): """是否爆掉""" return self.face_total() &gt; 21 def open_hand(self, i): """明牌""" return self.cards_on_hand[i] def clean_hand(self): """清空手牌并清空状态""" self.cards_on_hand.clear() self.stand = False self.bust = False def face_total(self): """手牌总点数""" temp = [card.face for card in self.cards_on_hand] j_count = temp.count(11) q_count = temp.count(12) k_count = temp.count(13) total = sum(temp) - j_count - q_count * 2 - k_count * 3 return total def black_jack_total(self): """21点计数""" temp = [card.face for card in self.cards_on_hand] a_count = temp.count(1) j_count = temp.count(11) q_count = temp.count(12) k_count = temp.count(13) total = sum(temp) - j_count - q_count * 2 - k_count * 3 for i in range(a_count): if total &lt; 21: total += 10 if total &gt; 21: total -= 10 return totalclass Black_Jack_Player(Black_Jack): """21点玩家""" def __init__(self, name): super().__init__(name) # 玩家初始赌注 self._money = 1000 # 下注额 self._bet = 0 @property def money(self): return self._money @money.setter def money(self, money): """下注""" self._money = money @property def bet(self): return self._bet @bet.setter def bet(self, bet): """下注""" self._bet = bet def double(self): """加倍""" self._bet *= 2 def surrender(self): """投降""" self._bet /= 2 def __str__(self): return "【%s】筹码:%d，点数:%d，牌面:%s" % ( self._name, self._money, self.black_jack_total(), self.cards_on_hand)class Banker(Black_Jack): """庄家""" def __init__(self, name): super().__init__(name) # 是否是黑杰克 def is_black_jack(self): return self.cards_on_hand[0].face in [10, 11, 12, 13] and self.cards_on_hand[1].face == 1 def __str__(self): return "【%s】点数:%d，牌面:%s" % (self._name, self.black_jack_total(), self.cards_on_hand)def get_key(card): return card.suite, card.facedef main(): p = Poker() # print(p.cards) banker = Banker('庄家') # 电脑玩家 com_players = [Black_Jack_Player('东邪'), Black_Jack_Player('西毒'), Black_Jack_Player('南帝'), Black_Jack_Player('北丐')] player = Black_Jack_Player('玩家') while True: # 洗牌 p.shuffle() # 下注 for com_player in com_players: com_player.bet = random.randint(1, com_player.money) print("【&#123;&#125;】下注：&#123;&#125;".format(com_player.name, com_player.bet)) print('玩家当前筹码：&#123;&#125;'.format(player.money)) ok = False while not ok: try: player.bet = int(input("玩家请下注：")) if player.bet &gt; player.money: raise ValueError ok = True except ValueError: # 下注异常 print('输入有误') ok = False for i in range(2): # 庄家拿牌 banker.get(p.next) # 玩家拿牌 player.get(p.next) print('玩家拿牌：&#123;&#125;'.format(player.cards_on_hand[i])) # 电脑拿牌 for com_player in com_players: com_player.get(p.next) # 本轮是否结束标志 END = False # 庄家明牌 print("庄家明牌为：&#123;&#125;".format(banker.open_hand(0))) if banker.is_black_jack(): print("\n庄家有Black Jack：&#123;&#125;".format(banker.cards_on_hand)) # 庄家停牌 banker.stand = True # 直接结算筹码，结束本轮 END = True # 玩家轮流拿牌/停牌 while not END: for com_player in com_players: # 如果电脑玩家没停牌和爆掉则拿牌 # print('抽牌前：&#123;&#125;, stand:&#123;&#125;, bust:&#123;&#125;'.format(com_player.name, com_player.stand, com_player.bust)) if not com_player.stand and not com_player.bust: if com_player.is_stand(): com_player.stand = True print("【&#123;&#125;】:\"停牌！\"".format(com_player.name)) else: # 局势不错选择翻倍 if com_player.face_total in [10, 11, 12] and com_player.money &gt;= com_player.bet * 2: com_player.double() print("【&#123;&#125;】:\"运气不错，加倍！\"".format(com_player.name)) print("【&#123;&#125;】拿牌".format(com_player.name)) com_player.get(p.next) if com_player.is_bust(): com_player.bust = True print("【&#123;&#125;】爆掉！！".format(com_player.name)) # elif com_player.is_stand(): # com_player.stand = True # print("【&#123;&#125;】:\"停牌！\"".format(com_player.name)) # print('抽牌后：&#123;&#125;, stand:&#123;&#125;, bust:&#123;&#125;'.format(com_player.name, com_player.stand, com_player.bust)) if not player.bust and not player.stand: while True: print("当前手牌:&#123;&#125;，庄家明牌为：&#123;&#125;".format(player.cards_on_hand, banker.cards_on_hand[0])) print("请选择:1.拿牌，2.停牌，3.加倍") choose = int(input("选择:")) if choose == 1 or choose == 3: if choose == 3 and player.money &gt;= player.bet * 2: player.double() elif choose == 3: print('筹码不足，无法加倍！') player.get(p.next) if player.is_bust(): player.bust = True print('庄家发牌，当前手牌：&#123;&#125;'.format(player.cards_on_hand)) break elif choose == 2: player.stand = True break # 投降 # elif choose == 4: # player.surrender() # player.stand = True # break else: print("选择错误，请重新选择") temp = 0 for com_player in com_players: if com_player.stand or com_player.bust: temp += 1 if temp == len(com_players) and (player.bust or player.stand): END = True # 庄家抽牌 while not banker.bust and not banker.stand: banker.get(p.next) if banker.is_bust(): banker.bust = True elif banker.is_stand(): banker.stand = True # 结算筹码 if banker.bust: for com_player in com_players: if not com_player.bust: com_player.money += com_player.bet else: com_player.money -= com_player.bet if not player.bust: player.money += player.bet else: player.money -= player.bet else: for com_player in com_players: if com_player.black_jack_total() &gt; banker.black_jack_total() and not com_player.bust: # 玩家为21点时赢得1.5倍赌注 if com_player.black_jack_total() == 21: com_player.bet *= 1.5 com_player.money += com_player.bet elif com_player.black_jack_total() == banker.black_jack_total() and not com_player.bust: pass else: com_player.money -= com_player.bet if player.black_jack_total() &gt; banker.black_jack_total() and not player.bust: # 玩家为21点时赢得1.5倍赌注 if player.black_jack_total() == 21: player.bet *= 1.5 player.money += player.bet elif player.black_jack_total() == banker.black_jack_total() and not player.bust: pass else: player.money -= player.bet # 结束一轮 print("=" * 45) print(banker) banker.clean_hand() for com_player in com_players: # 清空手牌 print(com_player, end='') com_player.clean_hand() # 筹码为零则离席 if com_player.money == 0: com_players.remove(com_player) print("\n【&#123;&#125;】倾家荡产,被保安拖走...".format(com_player.name)) print() print(player) player.clean_hand() print("=" * 45) input("本轮结束，请按回车继续") if player.money &lt;= 0: break print("筹码已用完，游戏结束！！")if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python 3</category>
      </categories>
      <tags>
        <tag>实例</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F07%2F30%2Fcjz5jrz9l000dk4da7wthyv42%2F</url>
    <content type="text"><![CDATA[​ 在笔试中经常会遇到很多需要手写代码的题，如果能完整的写出来最好，但如果不习惯手写或时间不够，可已选择写伪码，主要描述清楚关键的实现步骤。 笔试 写出Collection接口的实现 Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap 运行时获取class的磁盘路径 1&lt;YOUR CLASS&gt;.class.getProtectionDomain().getCodeSource().getSource().getLocation() Java多态的表现形式，代码如何实现 重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现；不同的对象调用同一个方法的到不同的结果。 继承父类 重写父类方法 向上转型 在工作中遇到或使用过的设计模式，手写实现一个设计模式（除了单例模式） Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），Observer（观察者模式）， State（状态模式）， Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。具体实现代码 手写代码，实现多线程对一整型对象递增，且数值不重复 123456789101112131415161718192021222324public class Test &#123; private static int num = 1; public static void main(String[] args) &#123; Test test = new Test(); Increasing inc = test.new Increasing(); for (int i=0;i&lt;=10;i++)&#123; Thread thread=new Thread(inc); thread.start(); &#125; &#125; private synchronized void add()&#123; num+=1; System.out.println(num); &#125; class Increasing implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;20;i++)&#123; add(); &#125; &#125; &#125;&#125; 快速获得数组int[] a = {1,2, 3, 5, 6, 12, 4, 7, 14, 9, 8}中第二大的数，写出关键代码 下面代码的时间复杂度为O(n)，不一定是最快的，但只需遍历一次 12345678910111213public static int getSecondMax(int[] a) &#123; int max = a[0]; int second = a[a.length - 1]; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; second = max; max = a[i]; &#125; else if (a[i] &gt; second &amp;&amp; a[i] &lt; max) &#123; second = a[i]; &#125; &#125; return second;&#125; 进程和线程的区别和联系？ 进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程线程 - 操作系统分配CPU的基本单位 面试 在之前项目中遇到什么问题，怎么解决。 mysql分页语句。 线程同步有哪几种方式。 eclipse的中查找类被调用的快捷键是什么。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3与Java的对比之面向对象]]></title>
    <url>%2F2019%2F07%2F28%2Fcjz5jrzbm001lk4daspmjuj8u%2F</url>
    <content type="text"><![CDATA[类(class)是构造对象的模板或蓝图。由类构造(construct)对象的过程称为创建类的实例(instance)。 ——Java核心技术 类提供了一种组合数据和功能的方法。创建一个新类意味着创建一个新类型的对象，从而允许创建一个该类型的新实例。 ——Python3.7.4文档 在对于类的定义上，Python3与Java定义一致。 类​ 下面分别用Java和Python3编写一个People类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * People */public class People &#123; //实例域（成员变量） private String name; private int age; private String gender; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; //无参构造器 public People() &#123; System.out.println("【JPeople】无参构造器"); &#125; //带参构造器 public People(String name, int age, String gender) &#123; System.out.println("【JPeople】带参构造器"); this.name = name; this.age = age; this.gender = gender; &#125; //静态方法 public static void f() &#123; System.out.println("【JPeople】静态方法"); &#125; //实例方法 public void sayHello() &#123; System.out.println("【JPeople】"+this.name + " say：\"Hello\""); pf(); &#125; //私有方法 private void pf()&#123; System.out.println("【JPeople】私有方法"); &#125;&#125;public class PeopleTest &#123; public static void main(String[] args) &#123; People tom = new People("tom", 18, "male"); tom.sayHello(); People.f(); &#125;&#125; ​ Java执行结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class People: """People""" # 私有属性 __gift = 100 # 类属性 name = '' age = 0 # 限定对象只能绑定_gender属性 # __slots__=('_gender') # 实例化方法 def __init__(self, name, age, gender): print("【PPeople】构造方法") self.name = name self.age = age self._gender = gender # getter方法 @property def gender(self): return self._gender # setter方法 @gender.setter def gender(self,gender): self._gender=gender # 静态方法 @staticmethod def sf(): print("【PPeople】静态方法") # 类方法 @classmethod def cf(cls): print("【PPeople】类方法") # 实例方法 def say_hello(self): print("【PPeople】&#123;&#125; say：\"Hello!\",gift=&#123;&#125;".format(self.name, self.__gift)) self.__pf() # 私有方法 def __pf(self): print("【PPeople】私有方法")People.age += 1print(People.age)People.sf()tom = People('Tom', 18, 'male')tom.gender="female"print(tom.gender)tom.say_hello() ​ Python执行结果 小结 Java Python 私有属性 （成员变量）使用private关键字修饰 属性名双下划线开头__；不建议将属性设置为私有，建议以_(单下划线)开头，暗示属性为受保护的，不建议外部直接访问，建议使用getter、setter进行操作 类属性 无 类和对象都可以访问 构造方法 有参、无参构造器；方法名与类名相同 (实例化方法)方法名固定__init__ 实例方法 对象访问 (普通方法)对象访问，默认有参self 私有方法 使用private关键字修饰 方法名双下划线开头__ 静态方法 使用static关键字修饰 使用@staticmethod装饰器,可以无参 类方法 无 使用@classmethod装饰器,类和对象访问,默认参数cls 继承​ 在Java中是单继承继承，而Python可以多继承；下面分别使用Java和Python 3实现Student子类 12345678910111213141516171819202122232425262728293031323334public class Student extends People&#123; //学号 private String studentNumber; public String getStudentNumber() &#123; return studentNumber; &#125; public void setStudentNumber(String studentNumber) &#123; this.studentNumber = studentNumber; &#125; //子类无参构造器 public Student() &#123; &#125; //带参构造器 public Student(String name, int age, String gender, String studentNumber) &#123; //调用父类带参构造器 super(name, age, gender); System.out.println("【JStudent】带参构造器"); this.studentNumber = studentNumber; &#125; //重写父类方法 public void sayHello()&#123; System.out.println("【JStudent】"+this.getName() + " say：\"Hello\""); &#125; public static void main(String[] args) &#123; Student student_1 = new Student("Jerry", 17, "male", "0021"); student_1.sayHello(); &#125;&#125; ​ Java执行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243# 单继承class Student(People): # 子类构造方法 def __init__(self, name, age, gender, student_number): print("【PStudent】构造方法--开始") # 调用超类构造方法 super(Student, self).__init__(name, age, gender) self.student_number = student_number print("【PStudent】构造方法--结束") # 重写父类方法 def say_hello(self): print("【PStudent】&#123;&#125; say：\"Hello!\"".format(self.name)) # Child类,为多继承做准备class Child: def __init__(self, name, mom, dad): print("【PChild】构造方法") self.name = name self.mom = mom self.dad = dad def cry(self): print('【PChild】'+self.name + ":\'wow wow\'")# 多重继承class Kid(Student, Child): def __init__(self, name, age, gender, student_number, mom, dad): print("【PKid】构造方法--开始") Student.__init__(self, name, age, gender, student_number) Child.__init__(self, name, mom, dad) print("【PKid】构造方法--结束") def info(self): print('【PKid】'+', '.join(['%s:%s' % item for item in self.__dict__.items()]))# 创建一个Student对象jerry = Student("Jerry", 17, 'male', '0021')print(jerry.name)jerry.say_hello()# 创建一个Kid对象kid = Kid("小明", 12, "男", "0023", "Tom", "Jerry")kid.info() ​ Python执行结果 小结​ Java与Python 3 在掉用构造方法时顺序是一致的，但是Java在构造方法内调用父类构造方法语句super()必须放在方法体的第一句；而Python 3，对象是由 __new__()和__init__()协作构造完成，实例通过__new__方法被创建，使用__init__方法进行初始化；所以在调用父类方法之前，可以对参数进行定制修改。Python 3 的多继承，在搜索从父类继承的方法/属性时，可以简单认为是深度优先、从左至右；但为了保持单次调用，实际在调用时是动态的； 多态​ 实现多态的步骤：1.继承父类 2.重写父类方法 3.向上转型 1234567891011121314/**1.Teacher继承自People**/public class Teacher extends People &#123; public Teacher() &#123; &#125; public Teacher(String name, int age, String gender) &#123; super(name, age, gender); &#125; //2.重写sayHello方法 public void sayHello() &#123; System.out.println("【JTeacher】"+this.getName() + "：\" 同学们早上好！\""); &#125;&#125; 123456789public class Test &#123; public static void main(String[] args) &#123; //3.向上转型 People teacher= new Teacher("王阳明",45,"男"); teacher.sayHello(); People student =new Student("小明", 17, "男", "0021"); student.sayHello(); &#125;&#125; java运行结果： 1234567891011121314class Teacher(People): """继承自People""" def __init__(self, name, age, gender): print("【PTeacher】构造方法--开始") super(Teacher, self).__init__(name, age, gender) print("【PTeacher】构造方法--结束") def say_hello(self): print("【PTeacher】&#123;&#125; say：\"同学们好！\"".format(self.name)) people_1 = Student("小明", 12, "男", "0023")people_1.say_hello()people_2 = Teacher("王阳明", 45, "男")people_2.say_hello() Python运行结果： 小结 Python从语法层面并没有像Java那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod（class CLASSNAME(metaclass=ABCMeta):）包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python3</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7查杀nanoWath挖矿木马]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5jrz8z0001k4da494oxlgn%2F</url>
    <content type="text"><![CDATA[前几天在查看服务器时状态时发现cpu占用率达到了103% 这个VPS主要是拿来玩玩，平时上面并没有什么大的服务再运行，不可能会占满CPU的；用shell客户端连上VPS，执行ps aux，其中一个叫nanoWatch的进程cpu占用率达到了99.5% 直接杀掉这个进程kill -9 17305,再检查进程，没发现异常 过了没几分钟，cpu占用又满了，查看进程，这个进程又出现了； 找到/tmp/nanoWatch这个文件，删掉这个文件，再杀掉进程，过了几分钟，进进程再次出现。 我怀疑是定时启动的任务， crontab -l查看cron计划任务，显示出来了两个定时任务，每5分钟和7分钟执行一次下载文件，我手动把这个文件下下来，是一个脚本 删除定时任务crontab -r，删掉文件，杀掉进程，结束了。 过了两天，又出现CPU占用异常。 我之前一直是用root用户并使用20端口进行ssh连接，这是非常不安全的行为，很容易被端口扫描暴力破解密码登录服务器。简单的解决办法如下 [TOC] 修改ssh连接端口用 root 用户进入 /etc/ssh/ 1234cd /etc/ssh/#用 vi 打开 sshd_config 文件vim sshd_config#添加端口20022（22号是默认端口，注释掉也是默认开启的），并解开22端口注释 123456789#重启ssh systemctl restart sshd#查看防火墙规则firewall-cmd --permanent --list-port#向防火墙中添加端口firewall-cmd --zone=public --add-port=20022/tcp --permanentreaload #重新加载防火墙规则firewall-cmd --reload 12#查看20022端口是否添加成功firewall-cmd --zone=public --query-port=20022/tcp 断开ssh连接，换用20022端口连接修改/etc/ssh/sshd_config将22号端口注释掉 1234#重启sshsystemctl restart sshd#查看ssh监听的端口ss -tnlp|grep ssh 禁用root登入，使用普通用户登入12345#先创建一个普通用户test,同时给test用户设置密码adduser testpasswd test#接着禁用root登录(修改sshd_config文件)vi /etc/ssh/sshd_config 12#重启sshSystemctl restart sshd.service]]></content>
      <categories>
        <category>服务器安全</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker启动Redis]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5jrz9c0007k4dapoymlhf9%2F</url>
    <content type="text"><![CDATA[12#docker中启动redis并设置密码docker run -d --name myredis -p 6379:6379 redis --requirepass "mypassword"]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装RabbitMq]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5jrz9d0008k4da3g0fra4q%2F</url>
    <content type="text"><![CDATA[12#设置rabbit默认用户与密码docker run -d --hostname rabbit-host --name rabbitMq -e RABBITMQ_DEFAULT_USER=username -e RABBITMQ_DEFAULT_PASS=password -p 5672:5672 -p 15672:15672 rabbitmq:3.7.3-management 12#在docker中停止rabbitMqdocker stop rabbitMq]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>RabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装Mysql5.7]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5jrz9f0009k4danl3sawx9%2F</url>
    <content type="text"><![CDATA[在Docker中mysql5.7安装和设置与8.0基本一致 1234567891011121314151617# docker 中下载 mysqldocker pull mysql:5.7#启动并设置root密码docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=your_password -d mysql:5.7#进入容器docker exec -it mysql bash#登录mysqlmysql -u root -p#设置root用户密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_password';#添加远程登录用户CREATE USER 'your_username'@'%' IDENTIFIED WITH mysql_native_password BY 'your_password';GRANT ALL PRIVILEGES ON *.* TO 'your_password'@'%';]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IDEA中使用Dockerfile]]></title>
    <url>%2F2019%2F07%2F21%2Fcjz5jrz9i000ck4dal9atmbzp%2F</url>
    <content type="text"><![CDATA[在IDEA中使用Dockerfile简单步骤 在项目根目录创建Dockerfile文件 在Dockerfile中写入 1234567891011#引用基础镜像FROM java:8-jre#将需要在Docker中运行的jar包复制到镜像中ADD target/*.jar applicationName.jar#暴露端口EXPOSE 8888#容器启动时执行的命令ENTRYPOINT ["java", "-jar", "applicationName.jar", "--server.port=8888"] 使用maven打包项目，运行Dockerfile文件 ps:启动前需要配置IDEA与Docker服务器的连接]]></content>
      <categories>
        <category>笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Dockerflie</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud配置SSH连接统一配置中心]]></title>
    <url>%2F2019%2F07%2F19%2Fcjz5jrz950003k4dal6jw65eh%2F</url>
    <content type="text"><![CDATA[当时在配置ssh连接的时候不知不觉就掉坑里去了，对一些知识点没完全理解； 先说说的掉坑，复制id_rsa文件内的文本出来，放进bootstrap.yml的privateKey中，如下图 启动报错 12Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under &apos;spring.cloud.config.server.git&apos; to org.springframework.cloud.config.server.environment.MultipleJGitEnvironmentProperties failed: Reason: Property &apos;spring.cloud.config.server.git.privateKey&apos; is not a valid private key 我们看看官网怎么配spring.cloud.config.server.git的 有没有发现不一样，没错，官网配置的privateKey里少了前3行属性为什么？？？因为官网的秘钥在生成时是没有设置秘钥密码的，而我们的秘钥是有密码的，它没办法解密秘钥；解决办法两种： ==我们在生成秘钥时也不设置秘钥密码== ==在yml中配置的git属性添加passphrase== 下面是全配置过程，主要分3步 生成公钥与私钥打开Git Bash/Terminal，输入ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 引号里面替换成你的邮箱地址或标志自己身份的信息 提示保存秘钥的文件位置，直接回车保持默认位置 设置秘钥密码（直接回车则不设置秘钥密码），生成公钥、秘钥 完成之后可以在/root/.ssh/目录下找到公钥（id_rsa.pub）秘钥（id_rsa） 将公钥添加到git上复制id_rsa.pub的内容出来 打开github，进入需要拉取文件的仓库，进入设置标签页 点击Add Deploy key 输入GitHub密码确认 刚添加的公钥是灰色的，还没有被使用 在bootstrap.yml中配置把id_rsa的全部内容复制出来，放到private-key属性 注意： uri要用ssh形式的地址 ignore-local-ssh-settings设置为true，忽略本地的ssh配置 passphrase内要配置上面设置的秘钥密码 启动项目后，可以在Github的仓库设置中看到公钥已经被使用，变成了绿色。 至此spring-cloud-config使用ssh连接git就配置完成。 修改秘钥密码打开Git Bash/Terminal，输入ls-al ~/.ssh 检查之前是否已经生成了SSH key 如果是这样的那就说明已经生成过秘钥，可以选择修改修改私钥密码（passphrase）输入 ssh-keygen -p 直接回车继续，输入旧密码，然后输入两次新密码]]></content>
      <categories>
        <category>Java</category>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
